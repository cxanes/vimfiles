#!/usr/bin/python
# $HeadURL: http://svn.berlios.de/svnroot/repos/mirageiv/trunk/mirage.py $
# $Id: mirage.py 210 2007-10-18 07:08:27Z stonecrest $
#
# Modified by Frank Chang <frank.nevermind@gmail.com>

__version__ = "0.9"

__license__ = """
Mirage, a fast GTK+ Image Viewer
Copyright 2007 Scott Horowitz <stonecrest@gmail.com>

This file is part of Mirage.

Mirage is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or
(at your option) any later version.

Mirage is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""

import pygtk
pygtk.require('2.0')
import gtk
import gtk.gdk
import os
import sys, getopt
import string
import gc
import random
import urllib
import gobject
import locale
import stat
import time
import subprocess
import shutil
import filecmp
import tempfile
import socket
import md5
import threading
try:
    import gconf
except:
    pass

if gtk.gtk_version < (2, 6, 0):
    sys.stderr.write("Mirage requires GTK+ 2.6.0 or newer..\n")
    sys.exit(1)
if gtk.pygtk_version < (2, 6, 0):
    sys.stderr.write("Mirage requires PyGTK 2.6.0 or newer.\n")
    sys.exit(1)
    
def valid_int(inputstring):
    try:
        x = int(inputstring)
        return True
    except:
        return False

class Base:

    def __init__(self):
        
        # gtk.gdk.threads_init()

        # Constants
        self.open_mode_smart = 0
        self.open_mode_fit = 1
        self.open_mode_1to1 = 2
        self.open_mode_last = 3
        self.min_zoomratio = 0.02

        # Initialize vars:
        width=800
        height=600
        bgcolor_found = False
        # Current image:
        self.curr_img_in_list = 0
        self.currimg_name = ""
        self.currimg_width = 0
        self.currimg_height = 0
        self.currimg_pixbuf = None
        self.currimg_pixbuf_original = None
        self.currimg_zoomratio = 1
        self.currimg_is_animation = False
        # This is the actual pixbuf that is loaded in Mirage. This will
        # usually be the same as self.curr_img_in_list except for scenarios
        # like when the user presses 'next image' multiple times in a row.
        # In this case, self.curr_img_in_list will increment while
        # self.loaded_img_in_list will retain the current loaded image.
        self.loaded_img_in_list = 0
        # Next preloaded image:
        self.preloadimg_next_in_list = -1
        self.preloadimg_next_name = ""
        self.preloadimg_next_width = 0
        self.preloadimg_next_height = 0
        self.preloadimg_next_pixbuf = None
        self.preloadimg_next_pixbuf_original = None
        self.preloadimg_next_zoomratio = 1
        self.preloadimg_next_is_animation = False
        # Previous preloaded image:
        self.preloadimg_prev_in_list = -1
        self.preloadimg_prev_name = ""
        self.preloadimg_prev_width = 0
        self.preloadimg_prev_height = 0
        self.preloadimg_prev_pixbuf = None
        self.preloadimg_prev_pixbuf_original = None
        self.preloadimg_prev_zoomratio = 1
        self.preloadimg_prev_is_animation = False
        # Settings, misc:
        self.thumbpane_show = True
        self.statusbar_show = True
        self.opendialogpath = ""
        self.zoom_quality = gtk.gdk.INTERP_BILINEAR
        self.recursive = False
        self.verbose = False
        self.image_loaded = False
        self.open_all_images = False                # open all images in the directory(ies)
        self.use_last_dir = True
        self.last_dir = os.path.expanduser("~")
        self.fixed_dir = os.path.expanduser("~")
        self.image_list = []
        self.open_mode = self.open_mode_smart
        self.last_mode = self.open_mode_smart
        self.listwrap_mode = 0                      # 0=no, 1=yes, 2=ask
        self.user_prompt_visible = False            # the "wrap?" prompt
        self.controls_moving = False
        self.zoomvalue = 2
        self.updating_adjustments = False
        self.disable_screensaver = True
        self.closing_app = False
        self.preloading_images = True
        self.searching_for_images = False
        self.preserve_aspect = True
        self.ignore_preserve_aspect_callback = False
        self.savemode = 2
        self.image_modified = False
        self.image_zoomed = False
        self.merge_id = None
        self.merge_id_recent = None
        self.actionGroupRecent = None
        self.recentfiles = ['', '', '', '', '']
        self.open_hidden_files = False
        self.thumbnail_sizes = ["128", "96", "72", "64", "48", "32"]
        self.thumbnail_size = 128                       # Default to 128 x 128
        self.thumbnail_loaded = []
        self.thumbpane_updating = False
        self.window_position = [-1, -1]
        self.default_background = ['#666666', '#999999']
        self.background = self.default_background
        self.single_mode = False

        # Read any passed options/arguments:
        try:
            opts, args = getopt.getopt(sys.argv[1:], "hvRVp:b:s:a", ["help", "version", "recursive", "verbose", "position=", "background=", "single:", "--all"])
        except getopt.GetoptError:
            # print help information and exit:
            self.print_usage()
            sys.exit(2)
        # If options were passed, perform action on them.
        if opts != []:
            for o, a in opts:
                if o in ("-v", "--version"):
                    self.print_version()
                    sys.exit(2)
                elif o in ("-h", "--help"):
                    self.print_usage()
                    sys.exit(2)
                elif o in ("-R", "--recursive"):
                    self.recursive = True
                elif o in ("-V", "--verbose"):
                    self.verbose = True
                elif o in ("-p", "--position"):
                    pos = a.split("+")
                    for i in range(len(pos)):
                        try:
                            temp = int(pos[i])
                            pos[i] = temp
                        except:
                            pass
                    if len(pos) > 0:
                        self.window_position[0] = pos[0] 
                    if len(pos) > 1:
                        self.window_position[1] = pos[1] 
                elif o in ("-b", "--background"):
                    self.background = [a, a]
                elif o in ("-s", "--single"):
                    args = [a]
                    self.single_mode     = True
                    self.thumbpane_show  = False
                    self.statusbar_show  = False
                    self.open_mode       = self.open_mode_1to1
                elif o in ("-a", "--all"):
                    self.open_all_images = True
                else:
                    self.print_usage()
                    sys.exit(2)

        self.blank_image = gtk.gdk.Pixbuf(gtk.gdk.COLORSPACE_RGB, True, 8, 122, 122)
        self.blank_image.fill(0xeeeeeeee)

        # Define the main menubar and toolbar:
        actions = (
            ('FileMenu', None, ('_File')),
			('EditMenu', None, ('_Edit')),
            ('ViewMenu', None, ('_View')),
            ('GoMenu', None, ('_Go')),
            ('Open Image', gtk.STOCK_OPEN, ('_Open Image...'), '<Ctrl>O', ('Open Image'), self.open_file),
            ('Open Remote Image', gtk.STOCK_NETWORK, ('_Open Remote image...'), None, ('Open Remote Image'), self.open_file_remote),
            ('Open Folder', gtk.STOCK_OPEN, ('Open _Folder...'), '<Ctrl>F', ('Open Folder'), self.open_folder),
            ('Save', gtk.STOCK_SAVE, ('_Save Image'), '<Ctrl>S', ('Save Image'), self.save_image),
            ('Save As', gtk.STOCK_SAVE, ('Save Image _As...'), '<Shift><Ctrl>S', ('Save Image As'), self.save_image_as),
            ('Quit', gtk.STOCK_QUIT, ('_Quit'), '<Ctrl>Q', ('Quit'), self.exit_app),
            ('Previous Image', gtk.STOCK_GO_BACK, ('_Previous Image'), 'Left', ('Previous Image'), self.goto_prev_image),
            ('Next Image', gtk.STOCK_GO_FORWARD, ('_Next Image'), 'Right', ('Next Image'), self.goto_next_image),
            ('Previous2', gtk.STOCK_GO_BACK, ('_Previous'), 'Left', ('Previous'), self.goto_prev_image),
            ('Next2', gtk.STOCK_GO_FORWARD, ('_Next'), 'Right', ('Next'), self.goto_next_image),
            ('Random Image', None, ('_Random Image'), 'R', ('Random Image'), self.goto_random_image),
            ('First Image', gtk.STOCK_GOTO_FIRST, ('_First Image'), 'Home', ('First Image'), self.goto_first_image),
            ('Last Image', gtk.STOCK_GOTO_LAST, ('_Last Image'), 'End', ('Last Image'), self.goto_last_image),
            ('In', gtk.STOCK_ZOOM_IN, ('Zoom _In'), '<Ctrl>Up', ('Zoom In'), self.zoom_in),
            ('Out', gtk.STOCK_ZOOM_OUT, ('Zoom _Out'), '<Ctrl>Down', ('Zoom Out'), self.zoom_out),
            ('Fit', gtk.STOCK_ZOOM_FIT, ('Zoom To _Fit'), '<Ctrl>0', ('Fit'), self.zoom_to_fit_window_action),
            ('1:1', gtk.STOCK_ZOOM_100, ('_1:1'), '<Ctrl>1', ('1:1'), self.zoom_1_to_1_action),
            ('Preferences', gtk.STOCK_PREFERENCES, ('_Preferences...'), None, ('Preferences'), self.show_prefs),
            ('Properties', gtk.STOCK_PROPERTIES, ('_Properties...'), None, ('Properties'), self.show_properties),
            ('Minus', None, '', 'minus', ('Zoom Out'), self.zoom_out),
            ('Plus', None, '', 'plus', ('Zoom In'), self.zoom_in),
            ('Equal', None, '', 'equal', ('Zoom In'), self.zoom_in),
            ('Space', None, '', 'space', ('Next'), self.goto_next_image),
            ('Ctrl-KP_Insert', None, '', '<Ctrl>KP_Insert', ('Fit'), self.zoom_to_fit_window_action),
            ('Ctrl-KP_End', None, '', '<Ctrl>KP_End', ('1:1'), self.zoom_1_to_1_action),
            ('Ctrl-KP_Subtract', None, '', '<Ctrl>KP_Subtract', ('Zoom Out'), self.zoom_out),
            ('Ctrl-KP_Add', None, '', '<Ctrl>KP_Add', ('Zoom In'), self.zoom_in),
            ('Ctrl-KP_0', None, '', '<Ctrl>KP_0', ('Fit'), self.zoom_to_fit_window_action),
            ('Ctrl-KP_1', None, '', '<Ctrl>KP_1', ('1:1'), self.zoom_1_to_1_action),
            ('Prev', None, '', 'Up', ('Previous Image'), self.goto_prev_image),
            ('Next', None, '', 'Down', ('Next Image'), self.goto_next_image)
            )
        toggle_actions = (
            ('Status Bar', None, ('_Status Bar'), None, ('Status Bar'), self.toggle_status_bar, self.statusbar_show),
            ('Thumbnails Pane', None, ('_Thumbnails Pane'), None, ('Thumbnails Pane'), self.toggle_thumbpane, self.thumbpane_show)
                )

        # Populate keys[]:
        self.keys=[]
        for i in range(len(actions)):
            if len(actions[i]) > 3:
                if actions[i][3] != None:
                    self.keys.append([actions[i][4], actions[i][3]])

        uiDescription = """
            <ui>
              <popup name="Popup">
                <menuitem action="Next Image"/>
                <menuitem action="Previous Image"/>
                <separator name="FM1"/>
                <menuitem action="Out"/>
                <menuitem action="In"/>
                <menuitem action="1:1"/>
                <menuitem action="Fit"/>
                <separator name="FM4"/>
                <separator name="FM3"/>
              </popup>
              <menubar name="MainMenu">
                <menu action="FileMenu">
                  <menuitem action="Open Image"/>
                  <menuitem action="Open Folder"/>
                  <menuitem action="Open Remote Image"/>
                  <separator name="FM2"/>
                  <menuitem action="Save"/>
                  <menuitem action="Save As"/>
                  <separator name="FM3"/>
                  <menuitem action="Properties"/>
                  <separator name="FM1"/>
                  <placeholder name="Recent Files">
                  </placeholder>
                  <separator name="FM4"/>
                  <menuitem action="Quit"/>
                </menu>
                <menu action="EditMenu">
                  <menuitem action="Preferences"/>
                </menu>
                <menu action="ViewMenu">
                  <menuitem action="Out"/>
                  <menuitem action="In"/>
                  <menuitem action="1:1"/>
                  <menuitem action="Fit"/>
                  <separator name="FM2"/>
                  <menuitem action="Thumbnails Pane"/>
                  <menuitem action="Status Bar"/>
                  <separator name="FM1"/>
               </menu>
                <menu action="GoMenu">
                  <menuitem action="Next Image"/>
                  <menuitem action="Previous Image"/>
                  <menuitem action="Random Image"/>
                  <separator name="FM1"/>
                  <menuitem action="First Image"/>
                  <menuitem action="Last Image"/>
                  <separator name="FM2"/>
                </menu>
              </menubar>
            </ui>
            """

        # Create interface
        self.window = gtk.Window(gtk.WINDOW_TOPLEVEL)
        self.update_title()
        vbox = gtk.VBox(False, 0)
        self.UIManager = gtk.UIManager()
        actionGroup = gtk.ActionGroup('Actions')
        actionGroup.add_actions(actions)
        actionGroup.add_toggle_actions(toggle_actions)
        self.UIManager.insert_action_group(actionGroup, 0)
        self.UIManager.add_ui_from_string(uiDescription)
        self.refresh_recent_files_menu()
        self.window.add_accel_group(self.UIManager.get_accel_group())
        self.menubar = self.UIManager.get_widget('/MainMenu')
        if not self.single_mode:
            vbox.pack_start(self.menubar, False, False, 0)
        self.layout = gtk.Layout()
        self.vscroll = gtk.VScrollbar(None)
        self.vscroll.set_adjustment(self.layout.get_vadjustment())
        self.hscroll = gtk.HScrollbar(None)
        self.hscroll.set_adjustment(self.layout.get_hadjustment())
        self.table = gtk.Table(3, 2, False)

        self.thumblist = gtk.ListStore(gtk.gdk.Pixbuf)
        self.thumbpane = gtk.TreeView(self.thumblist)
        self.thumbcolumn = gtk.TreeViewColumn(None)
        self.thumbcell = gtk.CellRendererPixbuf()
        self.thumbcolumn.set_sizing(gtk.TREE_VIEW_COLUMN_FIXED)
        self.thumbpane_set_size()
        self.thumbpane.append_column(self.thumbcolumn)
        self.thumbcolumn.pack_start(self.thumbcell, True)
        self.thumbcolumn.set_attributes(self.thumbcell, pixbuf=0)
        self.thumbpane.get_selection().set_mode(gtk.SELECTION_SINGLE)
        self.thumbpane.set_headers_visible(False)
        self.thumbpane.set_property('can-focus', False)
        self.thumbscroll = gtk.ScrolledWindow()
        self.thumbscroll.set_policy(gtk.POLICY_NEVER, gtk.POLICY_ALWAYS)
        self.thumbscroll.add(self.thumbpane)
        
        self.table.attach(self.thumbscroll, 0, 1, 0, 1, 0, gtk.FILL|gtk.EXPAND, 0, 0)
        self.table.attach(self.layout, 1, 2, 0, 1, gtk.FILL|gtk.EXPAND, gtk.FILL|gtk.EXPAND, 0, 0)
        self.table.attach(self.hscroll, 1, 2, 1, 2, gtk.FILL|gtk.SHRINK, gtk.FILL|gtk.SHRINK, 0, 0)
        self.table.attach(self.vscroll, 2, 3, 0, 1, gtk.FILL|gtk.SHRINK, gtk.FILL|gtk.SHRINK, 0, 0)
        vbox.pack_start(self.table, True, True, 0)
        if not bgcolor_found:
            self.bgcolor = gtk.gdk.Color(0, 0, 0) # Default to black
        self.layout.modify_bg(gtk.STATE_NORMAL, self.bgcolor)
        self.imageview = gtk.Image()
        self.layout.add(self.imageview)

        self.statusbar = gtk.Statusbar()
        self.statusbar2 = gtk.Statusbar()
        self.statusbar.set_has_resize_grip(False)
        self.statusbar2.set_has_resize_grip(True)
        self.statusbar2.set_size_request(200, -1)
        hbox_statusbar = gtk.HBox()
        hbox_statusbar.pack_start(self.statusbar, expand=True)
        hbox_statusbar.pack_start(self.statusbar2, expand=False)
        vbox.pack_start(hbox_statusbar, False, False, 0)
        self.window.add(vbox)
        self.window.set_property('allow-shrink', False)
        self.window.set_default_size(width,height)
        
        # Connect signals
        self.window.connect("delete_event", self.delete_event)
        self.window.connect("destroy", self.destroy)
        self.window.connect("size-allocate", self.window_resized)
        self.window.connect('key-press-event', self.topwindow_keypress)
        self.layout.drag_dest_set(gtk.DEST_DEFAULT_HIGHLIGHT | gtk.DEST_DEFAULT_DROP, [("text/uri-list", 0, 80)], gtk.gdk.ACTION_DEFAULT)
        self.layout.connect('drag_motion', self.motion_cb)
        self.layout.connect('drag_data_received', self.drop_cb)
        self.layout.add_events(gtk.gdk.KEY_PRESS_MASK | gtk.gdk.POINTER_MOTION_MASK | gtk.gdk.BUTTON_PRESS_MASK | gtk.gdk.BUTTON_MOTION_MASK | gtk.gdk.SCROLL_MASK)
        self.layout.connect("scroll-event", self.mousewheel_scrolled)
        self.layout.add_events(gtk.gdk.BUTTON_PRESS_MASK | gtk.gdk.KEY_PRESS_MASK)
        self.layout.connect("button_press_event", self.button_pressed)
        self.layout.add_events(gtk.gdk.POINTER_MOTION_MASK | gtk.gdk.POINTER_MOTION_HINT_MASK | gtk.gdk.BUTTON_RELEASE_MASK)
        self.layout.connect("motion-notify-event", self.mouse_moved)
        self.layout.connect("button-release-event", self.button_released)
        self.imageview.connect("expose-event", self.expose_event)
        self.thumb_sel_handler = self.thumbpane.get_selection().connect('changed', self.thumbpane_selection_changed)
        self.thumb_scroll_handler = self.thumbscroll.get_vscrollbar().connect("value-changed", self.thumbpane_scrolled)

        # Show GUI:
        if not self.statusbar_show:
            self.statusbar.set_property('visible', False)
            self.statusbar.set_no_show_all(True)
            self.statusbar2.set_property('visible', False)
            self.statusbar2.set_no_show_all(True)
        if not self.thumbpane_show:
            self.thumbscroll.set_property('visible', False)
            self.thumbscroll.set_no_show_all(True)
        self.hscroll.set_no_show_all(True)
        self.vscroll.set_no_show_all(True)
        self.window.show_all()
        self.layout.set_flags(gtk.CAN_FOCUS)
        current_position = self.window.get_position()
        self.window.set_focus(self.layout)
        if self.window_position[0] < 0:
            self.window_position[0] = current_position[0]
        if self.window_position[1] < 0:
            self.window_position[1] = current_position[1]

        self.window.move(self.window_position[0], self.window_position[1])

        # If arguments (filenames) were passed, try to open them:
        self.image_list = []
        if args != []:
            for i in range(len(args)):
                if sys.platform == 'win32':
                    try:
                        temp = unicode(args[i], 'utf8', 'strict')
                        args[i] = temp
                    except:
                        args[i] = unicode(args[i], sys.getfilesystemencoding(), 'strict')
                args[i] = urllib.url2pathname(args[i])
            self.expand_filelist_and_load_image(args)
            if self.single_mode:
                size = list(self.window.get_default_size())
                extra = [0, 0]
                if self.currimg_width < size[0]:
                    size[0] = self.currimg_width
                else:
                    extra[1] = self.hscroll.style_get_property('slider-width')

                if self.currimg_height < size[1]:
                    size[1] = self.currimg_height
                else:
                    extra[0] = self.vscroll.style_get_property('slider-width')

                self.window.resize(size[0]+extra[0], size[1]+extra[1])
        else:
            self.set_go_sensitivities(False)
            self.set_image_sensitivities(False)

    def refresh_recent_files_menu(self):
        if self.merge_id_recent:
            self.UIManager.remove_ui(self.merge_id_recent)
        if self.actionGroupRecent:
            self.UIManager.remove_action_group(self.actionGroupRecent)
            self.actionGroupRecent = None
        self.actionGroupRecent = gtk.ActionGroup('RecentFiles')
        self.UIManager.ensure_update()
        for i in range(len(self.recentfiles)):
            if len(self.recentfiles[i]) > 0:
                filename = self.recentfiles[i].split("/")[-1]
                if len(filename) > 0:
                    if len(filename) > 27:
                        # Replace end of file name (excluding extension) with ..
                        try:
                            menu_name = filename[:25] + '..' + os.path.splitext(filename)[1]
                        except:
                            menu_name = filename[0]
                    else:
                        menu_name = filename
                    menu_name = menu_name.replace('_','__')
                    action = [(str(i), None, menu_name, '<Alt>' + str(i+1), None, self.recent_action_click)]
                    self.actionGroupRecent.add_actions(action)
        uiDescription = """
            <ui>
              <menubar name="MainMenu">
                <menu action="FileMenu">
                  <placeholder name="Recent Files">
            """
        for i in range(len(self.recentfiles)):
            if len(self.recentfiles[i]) > 0:
                uiDescription = uiDescription + """<menuitem action=\"""" + str(i) + """\"/>"""
        uiDescription = uiDescription + """</placeholder></menu></menubar></ui>"""
        self.merge_id_recent = self.UIManager.add_ui_from_string(uiDescription)
        self.UIManager.insert_action_group(self.actionGroupRecent, 0)

    def thumbpane_update_images(self, clear_first=False, force_upto_imgnum=-1):
        self.stop_now = False
        # When first populating the thumbpane, make sure we go up to at least
        # force_upto_imgnum so that we can show this image selected:
        if clear_first:
            self.thumbpane_clear_list()
        # Load all images up to the bottom ofo the visible thumbpane rect:
        rect = self.thumbpane.get_visible_rect()
        bottom_coord = rect.y + rect.height + self.thumbnail_size
        if bottom_coord > self.thumbpane_bottom_coord_loaded:
            self.thumbpane_bottom_coord_loaded = bottom_coord
        # update images:
        if not self.thumbpane_updating:
            thread = threading.Thread(target=self.thumbpane_update_pending_images, args=(force_upto_imgnum, None))
            thread.setDaemon(True)
            thread.start()
        
    def thumbpane_update_pending_images(self, force_upto_imgnum, foo):
        self.thumbpane_updating = True
        # Check to see if any images need their thumbnails generated.
        curr_coord = 0
        imgnum = 0
        while curr_coord < self.thumbpane_bottom_coord_loaded or imgnum <= force_upto_imgnum:
            if self.closing_app or self.stop_now:
                break
            if self.thumbpane_show:
                if imgnum >= len(self.image_list):
                    break
                self.thumbpane_set_image(self.image_list[imgnum], imgnum)
                curr_coord += self.thumbpane.get_background_area((imgnum,),self.thumbcolumn).height
                if force_upto_imgnum == imgnum:
                    # Verify that the user hasn't switched images while we're loading thumbnails:
                    if force_upto_imgnum == self.curr_img_in_list:
                        gobject.idle_add(self.thumbpane_select, force_upto_imgnum)
                imgnum += 1
            else:
                break
        self.thumbpane_updating = False
    
    def thumbpane_clear_list(self):
        self.thumbpane_bottom_coord_loaded = 0
        self.thumbscroll.get_vscrollbar().handler_block(self.thumb_scroll_handler)
        self.thumblist.clear()
        self.thumbscroll.get_vscrollbar().handler_unblock(self.thumb_scroll_handler)
        for image in self.image_list:
            blank_pix = self.get_blank_pix_for_image(image)
            self.thumblist.append([blank_pix])
        self.thumbnail_loaded = [False]*len(self.image_list)

    def thumbpane_set_image(self, image_name, imgnum, force_update=False):
        if self.thumbpane_show:
            if not self.thumbnail_loaded[imgnum] or force_update:
                filename, thumbfile = self.thumbnail_get_name(image_name)
                pix = self.thumbpane_get_pixbuf(thumbfile, filename, force_update)
                if pix:
                    if self.thumbnail_size != 128:
                        # 128 is the size of the saved thumbnail, so convert if different:
                        pix, image_width, image_height = self.get_pixbuf_of_size(pix, self.thumbnail_size)
                    self.thumbnail_loaded[imgnum] = True
                    self.thumbscroll.get_vscrollbar().handler_block(self.thumb_scroll_handler)
                    self.thumblist[imgnum] = [self.pixbuf_add_border(pix)]
                    self.thumbscroll.get_vscrollbar().handler_unblock(self.thumb_scroll_handler)
    
    def thumbnail_get_name(self, image_name):
        filename = os.path.expanduser('file://' + image_name)
        m = md5.new()
        m.update(filename)
        mhex = m.hexdigest()
        mhex_filename = os.path.expanduser('~/.thumbnails/normal/' + mhex + '.png')
        return filename, mhex_filename
        
    def thumbpane_get_pixbuf(self, thumb_url, image_url, force_generation):
        # Returns a valid pixbuf or None if a pixbuf cannot be generated. Tries to re-use
        # a thumbnail from ~/.thumbails/normal/, otherwise generates one with the
        # XDG filename: md5(file:///full/path/to/image).png
        try:
            if os.path.exists(thumb_url) and not force_generation:
                pix = gtk.gdk.pixbuf_new_from_file(thumb_url)
                return pix
            else:
                # Create the 128x128 thumbnail:
                imgfile = image_url
                if imgfile[:7] == 'file://':
                    imgfile = imgfile[7:]
                pix = gtk.gdk.pixbuf_new_from_file(imgfile)
                pix, image_width, image_height = self.get_pixbuf_of_size(pix, 128)
                # Save image to .thumbnails:
                pix.save(thumb_url, "png")
                return pix
        except:
            return None
    
    def thumbpane_load_image(self, treeview, imgnum):
        if imgnum != self.curr_img_in_list:
            gobject.idle_add(self.goto_image, str(imgnum), None)
        
    def thumbpane_selection_changed(self, treeview):
        try:
            model, paths = self.thumbpane.get_selection().get_selected_rows()
            imgnum = paths[0][0]
            if not self.thumbnail_loaded[imgnum]:
                self.thumbpane_set_image(self.image_list[imgnum], imgnum)
            gobject.idle_add(self.thumbpane_load_image, treeview, imgnum)
        except:
            pass
        
    def thumbpane_select(self, imgnum):
        if self.thumbpane_show:
            self.thumbpane.get_selection().handler_block(self.thumb_sel_handler)
            self.thumbpane.get_selection().select_path((imgnum,))
            self.thumbpane.scroll_to_cell((imgnum,))
            self.thumbpane.get_selection().handler_unblock(self.thumb_sel_handler)

    def thumbpane_set_size(self):
        self.thumbcolumn.set_fixed_width(self.thumbpane_get_size())
        self.window_resized(None, self.window.allocation, True)
    
    def thumbpane_get_size(self):
        return int(self.thumbnail_size * 1.3)
    
    def thumbpane_scrolled(self, range):
        self.thumbpane_update_images()

    def get_blank_pix_for_image(self, image):
        # Sizes the "blank image" icon for the thumbpane. This will ensure that we don't
        # load a humongous icon for a small pix, for example, and will keep the thumbnails
        # from shifting around when they are actually loaded.
        try:
            info = gtk.gdk.pixbuf_get_file_info(image)
            imgwidth = float(info[1])
            imgheight = float(info[2])
            if imgheight > self.thumbnail_size:
                if imgheight > imgwidth:
                    imgheight = self.thumbnail_size
                else:
                    imgheight = imgheight/imgwidth * self.thumbnail_size
            imgheight = 2 + int(imgheight) # Account for border that will be added to thumbnails..
            imgwidth = self.thumbnail_size
        except:
            imgheight = 2 + self.thumbnail_size
            imgwidth = self.thumbnail_size
        blank_pix = gtk.gdk.Pixbuf(gtk.gdk.COLORSPACE_RGB, True, 8, imgwidth, imgheight)
        blank_pix.fill(0x00000000)
        imgwidth2 = int(imgheight*0.8)
        imgheight2 = int(imgheight*0.8)
        composite_pix = self.blank_image.scale_simple(imgwidth2, imgheight2, gtk.gdk.INTERP_BILINEAR)
        leftcoord = int((imgwidth - imgwidth2)/2)
        topcoord = int((imgheight - imgheight2)/2)
        composite_pix.copy_area(0, 0, imgwidth2, imgheight2, blank_pix, leftcoord, topcoord)
        return blank_pix

    def topwindow_keypress(self, widget, event):
        # For whatever reason, 'Left' and 'Right' cannot be used as menu
        # accelerators so we will manually check for them here:
        if event.state != gtk.gdk.SHIFT_MASK and event.state != gtk.gdk.CONTROL_MASK and event.state != gtk.gdk.MOD1_MASK and event.state != gtk.gdk.CONTROL_MASK | gtk.gdk.MOD2_MASK and event.state != gtk.gdk.LOCK_MASK | gtk.gdk.CONTROL_MASK:
            if event.keyval == gtk.gdk.keyval_from_name('Left') or event.keyval == gtk.gdk.keyval_from_name('Up'):
                self.goto_prev_image(None)
                return
            elif event.keyval == gtk.gdk.keyval_from_name('Right') or event.keyval == gtk.gdk.keyval_from_name('Down'):
                self.goto_next_image(None)
                return

            if self.single_mode and event.keyval == gtk.gdk.keyval_from_name('Return'):
                self.exit_app(gtk.STOCK_QUIT)
                return
        shortcut = gtk.accelerator_name(event.keyval, event.state)
        if "Escape" in shortcut:
            self.stop_now = True
            self.searching_for_images = False
            while gtk.events_pending():
                gtk.main_iteration()
            self.update_title()
            return

    def recent_action_click(self, action):
        self.stop_now = True
        while gtk.events_pending():
            gtk.main_iteration()
        cancel = self.autosave_image()
        if cancel:
            return
        index = int(action.get_name())
        self.image_list = []
        self.curr_img_in_list = 0
        self.image_list.append(self.recentfiles[index])
        self.image_load_failed(False)
        self.recent_file_remove_and_refresh(index)
    
    def recent_file_remove_and_refresh(self, index_num):
        i = index_num
        while i < len(self.recentfiles)-1:
            self.recentfiles[i] = self.recentfiles[i+1]
            i = i + 1
        # Set last item empty:
        self.recentfiles[len(self.recentfiles)-1] = ''
        self.refresh_recent_files_menu()

    def recent_file_add_and_refresh(self, addfile):
        # First check if the filename is already in the list:
        for i in range(len(self.recentfiles)):
            if len(self.recentfiles[i]) > 0:
                if addfile == self.recentfiles[i]:
                    # If found in list, put to position 1 and decrement the rest:
                    j = i
                    while j > 0:
                        self.recentfiles[j] = self.recentfiles[j-1]
                        j = j - 1
                    self.recentfiles[0] = addfile
                    self.refresh_recent_files_menu()
                    return
        # If not found, put to position 1, decrement the rest:
        j = len(self.recentfiles)-1
        while j > 0:
            self.recentfiles[j] = self.recentfiles[j-1]
            j = j - 1
        if len(self.recentfiles) > 0:
            self.recentfiles[0] = addfile
            self.refresh_recent_files_menu()

    def set_go_sensitivities(self, enable):
        self.UIManager.get_widget('/MainMenu/GoMenu/Previous Image').set_sensitive(enable)
        self.UIManager.get_widget('/MainMenu/GoMenu/Next Image').set_sensitive(enable)
        self.UIManager.get_widget('/MainMenu/GoMenu/Random Image').set_sensitive(enable)
        self.UIManager.get_widget('/MainMenu/GoMenu/First Image').set_sensitive(enable)
        self.UIManager.get_widget('/MainMenu/GoMenu/Last Image').set_sensitive(enable)
        self.UIManager.get_widget('/Popup/Previous Image').set_sensitive(enable)
        self.UIManager.get_widget('/Popup/Next Image').set_sensitive(enable)

    def set_image_sensitivities(self, enable):
        self.set_zoom_in_sensitivities(enable)
        self.set_zoom_out_sensitivities(enable)
        self.UIManager.get_widget('/MainMenu/ViewMenu/1:1').set_sensitive(enable)
        self.UIManager.get_widget('/MainMenu/ViewMenu/Fit').set_sensitive(enable)
        self.UIManager.get_widget('/Popup/1:1').set_sensitive(enable)
        self.UIManager.get_widget('/Popup/Fit').set_sensitive(enable)
        self.UIManager.get_widget('/MainMenu/FileMenu/Save As').set_sensitive(enable)
        self.UIManager.get_widget('/MainMenu/FileMenu/Save').set_sensitive(False)
        self.UIManager.get_widget('/MainMenu/FileMenu/Properties').set_sensitive(False)
        # Only jpeg, png, and bmp images are currently supported for saving
        if len(self.image_list) > 0:
            try:
                filetype = gtk.gdk.pixbuf_get_file_info(self.currimg_name)[0]['name']
                self.UIManager.get_widget('/MainMenu/FileMenu/Properties').set_sensitive(True)
                if self.filetype_is_writable(filetype):
                    self.UIManager.get_widget('/MainMenu/FileMenu/Save').set_sensitive(enable)
            except:
                self.UIManager.get_widget('/MainMenu/FileMenu/Save').set_sensitive(False)

    def set_zoom_in_sensitivities(self, enable):
        self.UIManager.get_widget('/MainMenu/ViewMenu/In').set_sensitive(enable)
        self.UIManager.get_widget('/Popup/In').set_sensitive(enable)

    def set_zoom_out_sensitivities(self, enable):
        self.UIManager.get_widget('/MainMenu/ViewMenu/Out').set_sensitive(enable)
        self.UIManager.get_widget('/Popup/Out').set_sensitive(enable)

    def set_next_image_sensitivities(self, enable):
        self.UIManager.get_widget('/MainMenu/GoMenu/Next Image').set_sensitive(enable)
        self.UIManager.get_widget('/Popup/Next Image').set_sensitive(enable)

    def set_previous_image_sensitivities(self, enable):
        self.UIManager.get_widget('/MainMenu/GoMenu/Previous Image').set_sensitive(enable)
        self.UIManager.get_widget('/Popup/Previous Image').set_sensitive(enable)

    def set_first_image_sensitivities(self, enable):
        self.UIManager.get_widget('/MainMenu/GoMenu/First Image').set_sensitive(enable)

    def set_last_image_sensitivities(self, enable):
        self.UIManager.get_widget('/MainMenu/GoMenu/Last Image').set_sensitive(enable)

    def set_random_image_sensitivities(self, enable):
        self.UIManager.get_widget('/MainMenu/GoMenu/Random Image').set_sensitive(enable)

    def set_zoom_sensitivities(self):
        if not self.currimg_is_animation:
            self.set_zoom_out_sensitivities(True)
            self.set_zoom_in_sensitivities(True)
        else:
            self.set_zoom_out_sensitivities(False)
            self.set_zoom_in_sensitivities(False)

    def print_version(self):
        print ("Version: Mirage"), __version__
        print ("Website: http://mirageiv.berlios.de")

    def print_usage(self):
        self.print_version()
        print ""
        print ("Usage: mirage [OPTION]... FILES|FOLDERS...")
        print ""
        print ("Options") + ":"
        print "  -h, --help              " + ("Show this help and exit")
        print "  -v, --version           " + ("Show version information and exit")
        print "  -V, --verbose           " + ("Show more detailed information")
        print "  -R, --recursive         " + ("Recursively include all images found in")
        print "                          " + ("subdirectories of FOLDERS")
        print "  -p, --position 'x+y'    " + ("Open viewer on the position x and y")
        print "  -b, --background '#RGB' " + ("Set the background color of transparent image")
        print "  -s, --single            " + ("Single image mode")
        print "  -a, --all               " + ("Open all images in the same directory")

    def motion_cb(self, widget, context, x, y, time):
        context.drag_status(gtk.gdk.ACTION_COPY, time)
        return True

    def drop_cb(self, widget, context, x, y, selection, info, time):
        uri = selection.data.strip()
        path = urllib.url2pathname(uri)
        paths = path.rsplit('\n')
        for i, path in enumerate(paths):
            paths[i] = path.rstrip('\r')
        self.expand_filelist_and_load_image(paths)

    def put_error_image_to_window(self):
        self.imageview.set_from_stock(gtk.STOCK_MISSING_IMAGE, gtk.ICON_SIZE_LARGE_TOOLBAR)
        self.currimg_width = self.imageview.size_request()[0]
        self.currimg_height = self.imageview.size_request()[1]
        self.center_image()
        self.set_go_sensitivities(False)
        self.set_image_sensitivities(False)
        self.update_statusbar()
        self.loaded_img_in_list = -1
        return

    def expose_event(self, widget, event):
        if self.updating_adjustments:
            return
        self.updating_adjustments = True
        if self.hscroll.get_property('visible'):
            try:
                zoomratio = float(self.currimg_width)/self.previmg_width
                newvalue = abs(self.layout.get_hadjustment().get_value() * zoomratio + (self.available_image_width()) * (zoomratio - 1) / 2)
                if newvalue >= self.layout.get_hadjustment().lower and newvalue <= (self.layout.get_hadjustment().upper - self.layout.get_hadjustment().page_size):
                    self.layout.get_hadjustment().set_value(newvalue)
            except:
                pass
        if self.vscroll.get_property('visible'):
            try:
                newvalue = abs(self.layout.get_vadjustment().get_value() * zoomratio + (self.available_image_height()) * (zoomratio - 1) / 2)
                if newvalue >= self.layout.get_vadjustment().lower and newvalue <= (self.layout.get_vadjustment().upper - self.layout.get_vadjustment().page_size):
                    self.layout.get_vadjustment().set_value(newvalue)
                self.previmg_width = self.currimg_width
            except:
                pass
        self.updating_adjustments = False

    def window_resized(self, widget, allocation, force_update=False):
        # Update the image size on window resize if the current image was last fit:
        if self.image_loaded:
            if force_update or allocation.width != self.prevwinwidth or allocation.height != self.prevwinheight:
                if self.last_image_action_was_fit:
                    if self.last_image_action_was_smart_fit:
                        self.zoom_to_fit_or_1_to_1(None, False, False)
                    else:
                        self.zoom_to_fit_window(None, False, False)
                else:
                    self.center_image()
                self.load_new_image_stop_now()
                self.show_scrollbars_if_needed()
                # Also, regenerate preloaded image for new window size:
                self.preload_when_idle = gobject.idle_add(self.preload_next_image, True)
                self.preload_when_idle2 = gobject.idle_add(self.preload_prev_image, True)
        self.prevwinwidth = allocation.width
        self.prevwinheight = allocation.height
        return

    def delete_event(self, widget, event, data=None):
        cancel = self.autosave_image()
        if cancel:
            return True
        self.stop_now = True
        self.closing_app = True
        sys.exit(0)

    def destroy(self, event, data=None):
        cancel = self.autosave_image()
        if cancel:
            return True
        self.stop_now = True
        self.closing_app = True

    def exit_app(self, action):
        cancel = self.autosave_image()
        if cancel:
            return True
        self.stop_now = True
        self.closing_app = True
        sys.exit(0)

    def put_zoom_image_to_window(self, currimg_preloaded):
        self.window.window.freeze_updates()
        if not currimg_preloaded:
            # Always start with the original image to preserve quality!
            # Calculate image size:
            finalimg_width = int(self.currimg_pixbuf_original.get_width() * self.currimg_zoomratio)
            finalimg_height = int(self.currimg_pixbuf_original.get_height() * self.currimg_zoomratio)
            if not self.currimg_is_animation:
                # Scale image:
                if not self.currimg_pixbuf_original.get_has_alpha():
                    self.currimg_pixbuf = self.currimg_pixbuf_original.scale_simple(finalimg_width, finalimg_height, self.zoom_quality)
                else:
                    colormap = self.imageview.get_colormap()
                    try:
                        color1 = colormap.alloc_color(self.background[0], True, True)
                        color2 = colormap.alloc_color(self.background[1], True, True)
                    except ValueError:
                        self.background = self.default_background
                        color1 = colormap.alloc_color(self.background[0], True, True)
                        color2 = colormap.alloc_color(self.background[1], True, True)
                    self.currimg_pixbuf = self.currimg_pixbuf_original.composite_color_simple(finalimg_width, finalimg_height, self.zoom_quality, 255, 8, color1.pixel, color2.pixel)
            else:
                self.currimg_pixbuf = self.currimg_pixbuf_original
            self.currimg_width, self.currimg_height = finalimg_width, finalimg_height
        self.layout.set_size(self.currimg_width, self.currimg_height)
        self.center_image()
        self.show_scrollbars_if_needed()
        if not self.currimg_is_animation:
            self.imageview.set_from_pixbuf(self.currimg_pixbuf)
            self.previmage_is_animation = False
        else:
            self.imageview.set_from_animation(self.currimg_pixbuf)
            self.previmage_is_animation = True
        # Clean up (free memory) because I'm lazy
        gc.collect()
        self.window.window.thaw_updates()
        self.loaded_img_in_list = self.curr_img_in_list

    def show_scrollbars_if_needed(self):
        if self.currimg_width > self.available_image_width():
            self.hscroll.show()
        else:
            self.hscroll.hide()
        if self.currimg_height > self.available_image_height():
            self.vscroll.show()
        else:
            self.vscroll.hide()

    def center_image(self):
        scrollbar = [self.vscroll.style_get_property('slider-width'), \
                        self.hscroll.style_get_property('slider-width')]
        if not self.vscroll.get_property('visible'):
            scrollbar[0] = 0
        if not self.hscroll.get_property('visible'):
            scrollbar[1] = 0

        x_shift = int((self.available_image_width() - self.currimg_width-scrollbar[0])/2)
        if x_shift < 0:
            x_shift = 0
        y_shift = int((self.available_image_height() - self.currimg_height-scrollbar[1])/2)
        if y_shift < 0:
            y_shift = 0
        self.layout.move(self.imageview, x_shift, y_shift)

    def available_image_width(self):
        width = self.window.get_size()[0]
        if self.thumbpane_show:
            width -= self.thumbpane_get_size()
        return width

    def available_image_height(self):
        height = self.window.get_size()[1]
        if not self.single_mode:
            height -= self.menubar.size_request()[1]
        if self.statusbar_show:
            height -= self.statusbar.size_request()[1]
        return height

    def save_image(self, action):
        if self.UIManager.get_widget('/MainMenu/FileMenu/Save').get_property('sensitive'):
            self.save_image_now(self.currimg_name, gtk.gdk.pixbuf_get_file_info(self.currimg_name)[0]['name'])

    def save_image_as(self, action):
        dialog = gtk.FileChooserDialog(title=("Save As"),action=gtk.FILE_CHOOSER_ACTION_SAVE,buttons=(gtk.STOCK_CANCEL,gtk.RESPONSE_CANCEL,gtk.STOCK_SAVE,gtk.RESPONSE_OK))
        dialog.set_default_response(gtk.RESPONSE_OK)
        filename = os.path.basename(self.currimg_name)
        filetype = None
        dialog.set_current_folder(os.path.dirname(self.currimg_name))
        dialog.set_current_name(filename)
        dialog.set_do_overwrite_confirmation(True)
        response = dialog.run()
        if response == gtk.RESPONSE_OK:
            prev_name = self.currimg_name
            filename = dialog.get_filename()
            dialog.destroy()
            fileext = os.path.splitext(os.path.basename(filename))[1].lower()
            if len(fileext) > 0:
                fileext = fileext[1:]
            # Override filetype if user typed a filename with a different extension:
            for i in gtk.gdk.pixbuf_get_formats():
                if fileext in i['extensions']:
                    filetype = i['name']
            self.save_image_now(filename, filetype)
        else:
            dialog.destroy()
            
    def save_image_now(self, dest_name, filetype):
        try:
            self.change_cursor(gtk.gdk.Cursor(gtk.gdk.WATCH))
            while gtk.events_pending():
                gtk.main_iteration()
            if filetype == None:
                filetype = gtk.gdk.pixbuf_get_file_info(self.currimg_name)[0]['name']
            if self.filetype_is_writable(filetype):
                self.currimg_pixbuf_original.save(dest_name, filetype)
                self.currimg_name = dest_name
                self.image_list[self.curr_img_in_list] = dest_name
                self.update_title()
                self.update_statusbar()
                # Update thumbnail:
                gobject.idle_add(self.thumbpane_set_image, dest_name, self.curr_img_in_list, True)
                self.image_modified = False
            else:
                error_dialog = gtk.MessageDialog(self.window, gtk.DIALOG_MODAL, gtk.MESSAGE_WARNING, gtk.BUTTONS_YES_NO, ('The') + ' ' + filetype + ' ' + 'format is not supported for saving. Do you wish to save the file in a different format?')
                error_dialog.set_title(("Save"))
                response = error_dialog.run()
                if response == gtk.RESPONSE_YES:
                    error_dialog.destroy()
                    while gtk.events_pending():
                        gtk.main_iteration()
                    self.save_image_as(None)
                else:
                    error_dialog.destroy()
        except:
            error_dialog = gtk.MessageDialog(self.window, gtk.DIALOG_MODAL, gtk.MESSAGE_WARNING, gtk.BUTTONS_CLOSE, ('Unable to save ') + dest_name)
            error_dialog.set_title(("Save"))
            error_dialog.run()
            error_dialog.destroy()
        self.change_cursor(None)

    def autosave_image(self):
        # returns True if the user has canceled out of the dialog
        if self.image_modified:
            if self.savemode == 1:
                temp = self.UIManager.get_widget('/MainMenu/FileMenu/Save').get_property('sensitive')
                self.UIManager.get_widget('/MainMenu/FileMenu/Save').set_property('sensitive', True)
                self.save_image(None)
                self.UIManager.get_widget('/MainMenu/FileMenu/Save').set_property('sensitive', temp)
            elif self.savemode == 2:
                dialog = gtk.MessageDialog(self.window, gtk.DIALOG_MODAL | gtk.DIALOG_DESTROY_WITH_PARENT, gtk.MESSAGE_QUESTION, gtk.BUTTONS_NONE, ("The current image has been modified. Save changes?"))
                dialog.add_button(gtk.STOCK_CANCEL, gtk.RESPONSE_CANCEL)
                dialog.add_button(gtk.STOCK_NO, gtk.RESPONSE_NO)
                dialog.add_button(gtk.STOCK_SAVE, gtk.RESPONSE_YES)
                dialog.set_title(("Save?"))
                dialog.set_default_response(gtk.RESPONSE_YES)
                response = dialog.run()
                dialog.destroy()
                if response == gtk.RESPONSE_YES:
                    temp = self.UIManager.get_widget('/MainMenu/FileMenu/Save').get_property('sensitive')
                    self.UIManager.get_widget('/MainMenu/FileMenu/Save').set_property('sensitive', True)
                    self.save_image(None)
                    self.UIManager.get_widget('/MainMenu/FileMenu/Save').set_property('sensitive', temp)
                elif response != gtk.RESPONSE_NO:
                    return True

    def filetype_is_writable(self, filetype):
        # Determine if filetype is a writable format
        filetype_is_writable = True
        for i in gtk.gdk.pixbuf_get_formats():
            if filetype in i['extensions']:
                if i['is_writable']:
                    return True
        return False

    def open_file(self, action):
        self.stop_now = True
        while gtk.events_pending():
            gtk.main_iteration()
        self.open_file_or_folder(action, True)
    
    def open_file_remote(self, action):
        # Prompt user for the url:
        dialog = gtk.Dialog(("Open Remote"), self.window, gtk.DIALOG_MODAL, buttons=(gtk.STOCK_CANCEL,gtk.RESPONSE_CANCEL,gtk.STOCK_OPEN,gtk.RESPONSE_OK))
        location = gtk.Entry()
        location.set_size_request(300, -1)
        location.set_activates_default(True)
        hbox = gtk.HBox()
        hbox.pack_start(gtk.Label(("Image Location (URL)") + ":"), False, False, 5)
        hbox.pack_start(location, True, True, 5)
        dialog.vbox.pack_start(hbox, True, True, 10)
        dialog.set_default_response(gtk.RESPONSE_OK)
        dialog.vbox.show_all()
        dialog.connect('response', self.open_file_remote_response,  location)
        response = dialog.show()
    
    def open_file_remote_response(self, dialog, response, location):
        if response == gtk.RESPONSE_OK:
            filenames = []
            filenames.append(location.get_text())
            dialog.destroy()
            while gtk.events_pending():
                gtk.main_iteration()
            self.expand_filelist_and_load_image(filenames)
        else:
            dialog.destroy()

    def open_folder(self, action):
        self.stop_now = True
        while gtk.events_pending():
            gtk.main_iteration()
        self.open_file_or_folder(action, False)

    def open_file_or_folder(self, action, isfile):
        cancel = self.autosave_image()
        if cancel:
            return
        # If isfile = True, file; If isfile = False, folder
        dialog = gtk.FileChooserDialog(title=("Open"),action=gtk.FILE_CHOOSER_ACTION_OPEN,buttons=(gtk.STOCK_CANCEL,gtk.RESPONSE_CANCEL,gtk.STOCK_OPEN,gtk.RESPONSE_OK))
        if isfile:
            filter = gtk.FileFilter()
            filter.set_name(("Images"))
            filter.add_pixbuf_formats()
            dialog.add_filter(filter)
            filter = gtk.FileFilter()
            filter.set_name(("All files"))
            filter.add_pattern("*")
            dialog.add_filter(filter)
            preview = gtk.Image()
            dialog.set_preview_widget(preview)
            dialog.set_use_preview_label(False)
            dialog.connect("update-preview", self.update_preview, preview)
            recursivebutton = None
        else:
            dialog.set_action(gtk.FILE_CHOOSER_ACTION_SELECT_FOLDER)
            recursivebutton = gtk.CheckButton(label=("Include images in subdirectories"))
            dialog.set_extra_widget(recursivebutton)
        dialog.set_default_response(gtk.RESPONSE_OK)
        dialog.set_select_multiple(True)
        if self.use_last_dir:
            if self.last_dir != None:
                dialog.set_current_folder(self.last_dir)
        else:
            if self.fixed_dir != None:
                dialog.set_current_folder(self.fixed_dir)
        dialog.connect("response", self.open_file_or_folder_response, isfile, recursivebutton)
        response = dialog.show()
    
    def open_file_or_folder_response(self, dialog, response, isfile, recursivebutton):
        if response == gtk.RESPONSE_OK:
            if self.use_last_dir:
                self.last_dir = dialog.get_current_folder()
            if not isfile and recursivebutton.get_property('active'):
                self.recursive = True
            filenames = dialog.get_filenames()
            if sys.platform == 'win32':
                try:
                    filenames = map(lambda fn: unicode(fn, 'utf8', 'strict'), filenames)
                except:
                    filenames = map(lambda fn: unicode(fn, sys.getfilesystemencoding(), 'strict'), filenames)
            dialog.destroy()
            while gtk.events_pending():
                gtk.main_iteration()
            self.expand_filelist_and_load_image(filenames)
        else:
            dialog.destroy()

    def update_preview(self, file_chooser, preview):
        filename = file_chooser.get_preview_filename()
        pixbuf = None
        try:
            pixbuf = gtk.gdk.pixbuf_new_from_file_at_size(filename, 128, 128)
        except:
            pass
        if pixbuf == None:
            try:
                pixbuf = gtk.gdk.PixbufAnimation(filename).get_static_image()
                width = pixbuf.get_width()
                height = pixbuf.get_height()
                if width > height:
                    pixbuf = pixbuf.scale_simple(128, int(float(height)/width*128), self.zoom_quality)
                else:
                    pixbuf = pixbuf.scale_simple(int(float(width)/height*128), 128, self.zoom_quality)
            except:
                pass
        if pixbuf == None:
            pixbuf = gtk.gdk.Pixbuf(gtk.gdk.COLORSPACE_RGB, 1, 8, 128, 128)
            pixbuf.fill(0x00000000)
        preview.set_from_pixbuf(pixbuf)
        have_preview = True
        file_chooser.set_preview_widget_active(have_preview)
        del pixbuf
        gc.collect()

    def hide_cursor(self):
        return False

    def toggle_status_bar(self, action):
        if self.statusbar.get_property('visible'):
            self.statusbar.hide()
            self.statusbar2.hide()
            self.statusbar_show = False
        else:
            self.statusbar.show()
            self.statusbar2.show()
            self.statusbar_show = True
        if self.image_loaded and self.last_image_action_was_fit:
            if self.last_image_action_was_smart_fit:
                self.zoom_to_fit_or_1_to_1(None, False, False)
            else:
                self.zoom_to_fit_window(None, False, False)
                
    def toggle_thumbpane(self, action):
        if self.thumbscroll.get_property('visible'):
            self.thumbscroll.hide()
            self.thumbpane.hide()
            self.thumbpane_show = False
        else:
            self.thumbscroll.show()
            self.thumbpane.show()
            self.thumbpane_show = True
            self.stop_now = False
            gobject.idle_add(self.thumbpane_update_images, True, self.curr_img_in_list)
        if self.image_loaded and self.last_image_action_was_fit:
            if self.last_image_action_was_smart_fit:
                self.zoom_to_fit_or_1_to_1(None, False, False)
            else:
                self.zoom_to_fit_window(None, False, False)

    def update_statusbar(self):
        # Update status bar:
        try:
            st = os.stat(self.currimg_name)
            filesize = st[stat.ST_SIZE]/1000
            ratio = int(100 * self.currimg_zoomratio)
            status_text = str(self.currimg_pixbuf_original.get_width()) + "x" + str(self.currimg_pixbuf_original.get_height()) + "   " + str(filesize) + "KB   " + str(ratio) + "%   "
        except:
            status_text=("Cannot load image.")
        self.statusbar.push(self.statusbar.get_context_id(""), status_text)
        status_text = ""
        if self.searching_for_images:
            status_text = ('Scanning') + '...'
        self.statusbar2.push(self.statusbar2.get_context_id(""), status_text)

    def populate_treeview(self):
        self.tvcolumn0.clear()
        self.tvcolumn1.clear()
        self.tvcolumn2.clear()
        self.tvcolumn0.pack_start(self.cellbool)
        self.tvcolumn1.pack_start(self.cell)
        self.tvcolumn2.pack_start(self.cell)
        self.tvcolumn0.add_attribute(self.cellbool, "stock-id", 0)
        self.tvcolumn1.set_attributes(self.cell, markup=1)
        self.tvcolumn2.set_attributes(self.cell, text=2)
        self.tvcolumn1.set_expand(True)

    def show_properties(self, action):
        show_props = gtk.Dialog(("Properties"), self.window)
        show_props.set_has_separator(False)
        show_props.set_resizable(False)
        table = gtk.Table(3, 3, False)
        image = gtk.Image()
        animtest = gtk.gdk.PixbufAnimation(self.currimg_name)
        image_is_anim = False
        if animtest.is_static_image():
            pixbuf, image_width, image_height = self.get_pixbuf_of_size(self.currimg_pixbuf_original, 180)
        else:
            pixbuf, image_width, image_height = self.get_pixbuf_of_size(animtest.get_static_image(), 180)
            image_is_anim = True
        image.set_from_pixbuf(pixbuf)
        vbox_left = gtk.VBox()
        filename = gtk.Label(("File name") + ":")
        filename.set_alignment(1, 1)
        filedate = gtk.Label(("File date") + ":")
        filedate.set_alignment(1, 1)
        imagesize = gtk.Label(("Dimensions") + ":")
        imagesize.set_alignment(1, 1)
        filesize = gtk.Label(("File size") + ":")
        filesize.set_alignment(1, 1)
        filetype = gtk.Label(("File type") + ":")
        filetype.set_alignment(1, 1)
        transparency = gtk.Label(("Transparency") + ":")
        transparency.set_alignment(1, 1)
        animation = gtk.Label(("Animation") + ":")
        animation.set_alignment(1, 1)
        bits = gtk.Label(("Bits per sample") + ":")
        bits.set_alignment(1, 1)
        channels = gtk.Label(("Channels") + ":")
        channels.set_alignment(1, 1)
        vbox_left.pack_start(filename, False, False, 2)
        vbox_left.pack_start(filedate, False, False, 2)
        vbox_left.pack_start(imagesize, False, False, 2)
        vbox_left.pack_start(filesize, False, False, 2)
        vbox_left.pack_start(filetype, False, False, 2)
        vbox_left.pack_start(transparency, False, False, 2)
        vbox_left.pack_start(animation, False, False, 2)
        vbox_left.pack_start(bits, False, False, 2)
        vbox_left.pack_start(channels, False, False, 2)
        vbox_right = gtk.VBox()
        filestat = os.stat(self.currimg_name)
        filename2 = gtk.Label(os.path.basename(self.currimg_name))
        filedate2 = gtk.Label(time.strftime('%Y/%m/%d  %H:%M', time.localtime(filestat[stat.ST_ATIME])))
        imagesize2 = gtk.Label(str(self.currimg_pixbuf_original.get_width()) + "x" + str(self.currimg_pixbuf_original.get_height()))
        filetype2 = gtk.Label(gtk.gdk.pixbuf_get_file_info(self.currimg_name)[0]['mime_types'][0])
        filesize2 = gtk.Label(str(filestat[stat.ST_SIZE]/1000) + "KB")
        if not image_is_anim and pixbuf.get_has_alpha():
            transparency2 = gtk.Label(("Yes"))
        else:
            transparency2 = gtk.Label(("No"))
        if animtest.is_static_image():
            animation2 = gtk.Label(("No"))
        else:
            animation2 = gtk.Label(("Yes"))
        bits2 = gtk.Label(str(pixbuf.get_bits_per_sample()))
        channels2 = gtk.Label(str(pixbuf.get_n_channels()))
        filename2.set_alignment(0, 1)
        filedate2.set_alignment(0, 1)
        imagesize2.set_alignment(0, 1)
        filesize2.set_alignment(0, 1)
        filetype2.set_alignment(0, 1)
        transparency2.set_alignment(0, 1)
        animation2.set_alignment(0, 1)
        bits2.set_alignment(0, 1)
        channels2.set_alignment(0, 1)
        vbox_right.pack_start(filename2, False, False, 2)
        vbox_right.pack_start(filedate2, False, False, 2)
        vbox_right.pack_start(imagesize2, False, False, 2)
        vbox_right.pack_start(filesize2, False, False, 2)
        vbox_right.pack_start(filetype2, False, False, 2)
        vbox_right.pack_start(transparency2, False, False, 2)
        vbox_right.pack_start(animation2, False, False, 2)
        vbox_right.pack_start(bits2, False, False, 2)
        vbox_right.pack_start(channels2, False, False, 2)
        hbox = gtk.HBox()
        hbox.pack_start(vbox_left, False, False, 3)
        hbox.pack_start(vbox_right, False, False, 3)
        table.attach(image, 1, 2, 1, 3, gtk.FILL|gtk.EXPAND, gtk.FILL|gtk.EXPAND, 15, 0)
        table.attach(hbox, 2, 3, 1, 3, gtk.FILL|gtk.EXPAND, gtk.FILL|gtk.EXPAND, 15, 0)
        show_props.vbox.pack_start(table, False, False, 15)
        show_props.vbox.show_all()
        close_button = show_props.add_button(gtk.STOCK_CLOSE, gtk.RESPONSE_CLOSE)
        close_button.grab_focus()
        show_props.run()
        show_props.destroy()

    def show_prefs(self, action):
        prev_thumbnail_size = self.thumbnail_size
        self.prefs_dialog = gtk.Dialog(("Mirage Preferences"), self.window)
        self.prefs_dialog.set_has_separator(False)
        self.prefs_dialog.set_resizable(False)
        # "Interface" prefs:
        table_settings = gtk.Table(14, 3, False)
        bglabel = gtk.Label()
        bglabel.set_markup('<b>' + ('Interface') + '</b>')
        bglabel.set_alignment(0, 1)
        color_hbox = gtk.HBox(False, 0)
        colortext = gtk.Label(('Background color') + ':  ')
        colorbutton = gtk.ColorButton(self.bgcolor)
        colorbutton.connect('color-set', self.bgcolor_selected)
        colorbutton.set_size_request(150, -1)
        gtk.Tooltips().set_tip(colorbutton, ("Sets the background color for the application."))
        color_hbox.pack_start(colortext, False, False, 0)
        color_hbox.pack_start(colorbutton, False, False, 0)
        color_hbox.pack_start(gtk.Label(), True, True, 0)
        thumbbox = gtk.HBox()
        thumblabel = gtk.Label(("Thumbnail size") + ":  ")
        thumbbox.pack_start(thumblabel, False, False, 0)
        thumbsize = gtk.combo_box_new_text()
        option = 0
        for size in self.thumbnail_sizes:
            thumbsize.append_text(size + " x " + size)
            if self.thumbnail_size == int(size):
                thumbsize.set_active(option)
            option += 1
        thumbbox.pack_start(thumbsize, False, False, 5)
        table_settings.attach(gtk.Label(), 1, 3, 1, 2, gtk.FILL|gtk.EXPAND, gtk.FILL|gtk.EXPAND, 0, 0)
        table_settings.attach(bglabel, 1, 3, 2, 3, gtk.FILL|gtk.EXPAND, gtk.FILL|gtk.EXPAND, 15, 0)
        table_settings.attach(gtk.Label(), 1, 3, 3, 4, gtk.FILL|gtk.EXPAND, gtk.FILL|gtk.EXPAND, 0, 0)
        table_settings.attach(color_hbox, 1, 2, 4, 5, gtk.FILL|gtk.EXPAND, gtk.FILL|gtk.EXPAND, 30, 0)
        table_settings.attach(gtk.Label(), 1, 3, 5, 6, gtk.FILL|gtk.EXPAND, gtk.FILL|gtk.EXPAND, 0, 0)
        table_settings.attach(thumbbox, 1, 3, 6, 7, gtk.FILL|gtk.EXPAND, gtk.FILL|gtk.EXPAND, 30, 0)
        table_settings.attach(gtk.Label(), 1, 3, 7, 8,  gtk.FILL|gtk.EXPAND, gtk.FILL|gtk.EXPAND, 30, 0)
        table_settings.attach(gtk.Label(), 1, 3, 9, 10, gtk.FILL|gtk.EXPAND, gtk.FILL|gtk.EXPAND, 30, 0)
        table_settings.attach(gtk.Label(), 1, 3, 10, 11,  gtk.FILL|gtk.EXPAND, gtk.FILL|gtk.EXPAND, 30, 0)
        table_settings.attach(gtk.Label(), 1, 3, 11, 12,  gtk.FILL|gtk.EXPAND, gtk.FILL|gtk.EXPAND, 30, 0)
        table_settings.attach(gtk.Label(), 1, 3, 12, 13,  gtk.FILL|gtk.EXPAND, gtk.FILL|gtk.EXPAND, 30, 0)
        table_settings.attach(gtk.Label(), 1, 3, 13, 14,  gtk.FILL|gtk.EXPAND, gtk.FILL|gtk.EXPAND, 30, 0)
        # "Behavior" tab:
        table_behavior = gtk.Table(14, 2, False)
        openlabel = gtk.Label()
        openlabel.set_markup('<b>' + ('Open Behavior') + '</b>')
        openlabel.set_alignment(0, 1)
        hbox_openmode = gtk.HBox()
        hbox_openmode.pack_start(gtk.Label(('Open new image in') + ':'), False, False, 0)
        combobox = gtk.combo_box_new_text()
        combobox.append_text(("Smart Mode"))
        combobox.append_text(("Zoom To Fit Mode"))
        combobox.append_text(("1:1 Mode"))
        combobox.append_text(("Last Active Mode"))
        combobox.set_active(self.open_mode)
        hbox_openmode.pack_start(combobox, False, False, 5)
        openallimages = gtk.CheckButton(("Load all images in current directory"))
        openallimages.set_active(self.open_all_images)
        gtk.Tooltips().set_tip(openallimages, ("If enabled, opening an image in Mirage will automatically load all images found in that image's directory."))
        hiddenimages = gtk.CheckButton(("Allow loading hidden files"))
        hiddenimages.set_active(self.open_hidden_files)
        gtk.Tooltips().set_tip(openallimages, ("If checked, opening, Mirage will open hidden files. Otherwise, hidden files will be ignored."))
        openpref = gtk.RadioButton()
        openpref1 = gtk.RadioButton(group=openpref, label=("Use last chosen directory"))
        gtk.Tooltips().set_tip(openpref1, ("The default 'Open' directory will be the last directory used."))
        openpref2 = gtk.RadioButton(group=openpref, label=("Use this fixed directory") + ":")
        openpref2.connect('toggled', self.prefs_use_fixed_dir_clicked)
        gtk.Tooltips().set_tip(openpref2, ("The default 'Open' directory will be this specified directory."))
        hbox_defaultdir = gtk.HBox()
        self.defaultdir = gtk.Button()
        hbox_defaultdir.pack_start(gtk.Label(), True, True, 0)
        hbox_defaultdir.pack_start(self.defaultdir, False, False, 0)
        hbox_defaultdir.pack_start(gtk.Label(), True, True, 0)
        if len(self.fixed_dir) > 25:
            self.defaultdir.set_label('...' + self.fixed_dir[-22:])
        else:
            self.defaultdir.set_label(self.fixed_dir)
        self.defaultdir.connect('clicked', self.defaultdir_clicked)
        self.defaultdir.set_size_request(250, -1)
        if self.use_last_dir:
            openpref1.set_active(True)
            self.defaultdir.set_sensitive(False)
        else:
            openpref2.set_active(True)
            self.defaultdir.set_sensitive(True)
        table_behavior.attach(gtk.Label(), 1, 2, 1, 2, gtk.FILL|gtk.EXPAND, gtk.FILL|gtk.EXPAND, 0, 0)
        table_behavior.attach(openlabel, 1, 2, 2, 3, gtk.FILL|gtk.EXPAND, gtk.FILL|gtk.EXPAND, 15, 0)
        table_behavior.attach(gtk.Label(), 1, 2, 3, 4, gtk.FILL|gtk.EXPAND, gtk.FILL|gtk.EXPAND, 0, 0)
        table_behavior.attach(hbox_openmode, 1, 2, 4, 5, gtk.FILL|gtk.EXPAND, gtk.FILL|gtk.EXPAND, 30, 0)
        table_behavior.attach(gtk.Label(), 1, 2, 5, 6, gtk.FILL|gtk.EXPAND, gtk.FILL|gtk.EXPAND, 0, 0)
        table_behavior.attach(openallimages, 1, 2, 6, 7, gtk.FILL|gtk.EXPAND, gtk.FILL|gtk.EXPAND, 30, 0)
        table_behavior.attach(hiddenimages, 1, 2, 7, 8, gtk.FILL|gtk.EXPAND, gtk.FILL|gtk.EXPAND, 30, 0)
        table_behavior.attach(gtk.Label(), 1, 2, 8, 9, gtk.FILL|gtk.EXPAND, gtk.FILL|gtk.EXPAND, 0, 0)
        table_behavior.attach(openpref1, 1, 2, 9, 10, gtk.FILL|gtk.EXPAND, gtk.FILL|gtk.EXPAND, 30, 0)
        table_behavior.attach(openpref2, 1, 2, 10, 11, gtk.FILL|gtk.EXPAND, gtk.FILL|gtk.EXPAND, 30, 0)
        table_behavior.attach(hbox_defaultdir, 1, 2, 11, 12, gtk.FILL|gtk.EXPAND, gtk.FILL|gtk.EXPAND, 45, 0)
        table_behavior.attach(gtk.Label(), 1, 2, 12, 13, gtk.FILL|gtk.EXPAND, gtk.FILL|gtk.EXPAND, 45, 0)
        # "Navigation" tab:
        table_navigation = gtk.Table(14, 2, False)
        navlabel = gtk.Label()
        navlabel.set_markup('<b>' + ('Navigation') + '</b>')
        navlabel.set_alignment(0, 1)
        preloadnav = gtk.CheckButton(label=("Preload images for faster navigation"))
        preloadnav.set_active(self.preloading_images)
        gtk.Tooltips().set_tip(preloadnav, ("If enabled, the next and previous images in the list will be preloaded during idle time. Note that the speed increase comes at the expense of memory usage, so it is recommended to disable this option on machines with limited ram."))
        hbox_listwrap = gtk.HBox()
        hbox_listwrap.pack_start(gtk.Label(("Wrap around imagelist") + ":"), False, False, 0)
        combobox2 = gtk.combo_box_new_text()
        combobox2.append_text(("No"))
        combobox2.append_text(("Yes"))
        combobox2.append_text(("Prompt User"))
        combobox2.set_active(self.listwrap_mode)
        hbox_listwrap.pack_start(combobox2, False, False, 5)
        table_navigation.attach(gtk.Label(), 1, 2, 1, 2, gtk.FILL|gtk.EXPAND, gtk.FILL|gtk.EXPAND, 0, 0)
        table_navigation.attach(navlabel, 1, 2, 2, 3, gtk.FILL|gtk.EXPAND, gtk.FILL|gtk.EXPAND, 15, 0)
        table_navigation.attach(gtk.Label(), 1, 2, 3, 4, gtk.FILL|gtk.EXPAND, gtk.FILL|gtk.EXPAND, 0, 0)
        table_navigation.attach(hbox_listwrap, 1, 2, 4, 5, gtk.FILL|gtk.EXPAND, gtk.FILL|gtk.EXPAND, 30, 0)
        table_navigation.attach(gtk.Label(), 1, 2, 5, 6, gtk.FILL|gtk.EXPAND, gtk.FILL|gtk.EXPAND, 0, 0)
        table_navigation.attach(preloadnav, 1, 2, 6, 7, gtk.FILL|gtk.EXPAND, gtk.FILL|gtk.EXPAND, 30, 0)
        table_navigation.attach(gtk.Label(), 1, 2, 7, 8, gtk.FILL|gtk.EXPAND, gtk.FILL|gtk.EXPAND, 30, 0)
        table_navigation.attach(gtk.Label(), 1, 2, 8, 9, gtk.FILL|gtk.EXPAND, gtk.FILL|gtk.EXPAND, 0, 0)
        table_navigation.attach(gtk.Label(), 1, 2, 9, 10, gtk.FILL|gtk.EXPAND, gtk.FILL|gtk.EXPAND, 30, 0)
        table_navigation.attach(gtk.Label(), 1, 2, 10, 11, gtk.FILL|gtk.EXPAND, gtk.FILL|gtk.EXPAND, 30, 0)
        table_navigation.attach(gtk.Label(), 1, 2, 11, 12, gtk.FILL|gtk.EXPAND, gtk.FILL|gtk.EXPAND, 0, 0)
        table_navigation.attach(gtk.Label(), 1, 2, 12, 13, gtk.FILL|gtk.EXPAND, gtk.FILL|gtk.EXPAND, 0, 0)
        table_navigation.attach(gtk.Label(), 1, 2, 13, 14, gtk.FILL|gtk.EXPAND, gtk.FILL|gtk.EXPAND, 0, 0)
        # "Image" tab:
        table_image = gtk.Table(14, 2, False)
        zoom_hbox = gtk.HBox()
        zoom_hbox.pack_start(gtk.Label(('Scaling quality') + ": "), False, False, 0)
        zoomcombo = gtk.combo_box_new_text()
        zoomcombo.append_text(("Nearest (Fastest)"))
        zoomcombo.append_text(("Tiles"))
        zoomcombo.append_text(("Bilinear"))
        zoomcombo.append_text(("Hyper (Best)"))
        zoomcombo.set_active(self.zoomvalue)
        zoom_hbox.pack_start(zoomcombo, False, False, 0)
        zoom_hbox.pack_start(gtk.Label(), True, True, 0)
        hbox_save = gtk.HBox()
        savelabel = gtk.Label(("Modified images") + ":")
        savecombo = gtk.combo_box_new_text()
        savecombo.append_text(("Ignore Changes"))
        savecombo.append_text(("Auto-Save"))
        savecombo.append_text(("Prompt For Action"))
        savecombo.set_active(self.savemode)
        hbox_save.pack_start(savelabel, False, False, 0)
        hbox_save.pack_start(savecombo, False, False, 5)
        table_image.attach(gtk.Label(), 1, 3, 1, 2,  gtk.FILL|gtk.EXPAND, gtk.FILL|gtk.EXPAND, 30, 0)
        table_image.attach(gtk.Label(), 1, 3, 3, 4,  gtk.FILL|gtk.EXPAND, gtk.FILL|gtk.EXPAND, 30, 0)
        table_image.attach(zoom_hbox, 1, 3, 4, 5,  gtk.FILL|gtk.EXPAND, gtk.FILL|gtk.EXPAND, 30, 0)
        table_image.attach(gtk.Label(), 1, 3, 5, 6,  gtk.FILL|gtk.EXPAND, gtk.FILL|gtk.EXPAND, 30, 0)
        table_image.attach(hbox_save, 1, 3, 6, 7, gtk.FILL|gtk.EXPAND, gtk.FILL|gtk.EXPAND, 30, 0)
        table_image.attach(gtk.Label(), 1, 3, 7, 8,  gtk.FILL|gtk.EXPAND, gtk.FILL|gtk.EXPAND, 30, 0)
        table_image.attach(gtk.Label(), 1, 3, 9, 10, gtk.FILL|gtk.EXPAND, gtk.FILL|gtk.EXPAND, 30, 0)
        table_image.attach(gtk.Label(), 1, 3, 10, 11,  gtk.FILL|gtk.EXPAND, gtk.FILL|gtk.EXPAND, 30, 0)
        table_image.attach(gtk.Label(), 1, 3, 11, 12,  gtk.FILL|gtk.EXPAND, gtk.FILL|gtk.EXPAND, 30, 0)
        table_image.attach(gtk.Label(), 1, 3, 12, 13,  gtk.FILL|gtk.EXPAND, gtk.FILL|gtk.EXPAND, 30, 0)
        table_image.attach(gtk.Label(), 1, 3, 13, 14,  gtk.FILL|gtk.EXPAND, gtk.FILL|gtk.EXPAND, 30, 0)
        # Add tabs:
        notebook = gtk.Notebook()
        notebook.append_page(table_behavior, gtk.Label(("Behavior")))
        notebook.append_page(table_navigation, gtk.Label(("Navigation")))
        notebook.append_page(table_settings, gtk.Label(("Interface")))
        notebook.append_page(table_image, gtk.Label(("Image")))
        notebook.set_current_page(0)
        hbox = gtk.HBox()
        self.prefs_dialog.vbox.pack_start(hbox, False, False, 7)
        hbox.pack_start(notebook, False, False, 7)
        notebook.connect('switch-page', self.prefs_tab_switched)
        # Show prefs:
        self.prefs_dialog.vbox.show_all()
        self.close_button = self.prefs_dialog.add_button(gtk.STOCK_CLOSE, gtk.RESPONSE_CLOSE)
        self.close_button.grab_focus()
        response = self.prefs_dialog.run()
        if response == gtk.RESPONSE_CLOSE or response == gtk.RESPONSE_DELETE_EVENT:
            self.zoomvalue = zoomcombo.get_active()
            if int(round(self.zoomvalue, 0)) == 0:
                self.zoom_quality = gtk.gdk.INTERP_NEAREST
            elif int(round(self.zoomvalue, 0)) == 1:
                self.zoom_quality = gtk.gdk.INTERP_TILES
            elif int(round(self.zoomvalue, 0)) == 2:
                self.zoom_quality = gtk.gdk.INTERP_BILINEAR
            elif int(round(self.zoomvalue, 0)) == 3:
                self.zoom_quality = gtk.gdk.INTERP_HYPER
            self.open_all_images = openallimages.get_active()
            self.open_hidden_files = hiddenimages.get_active()
            if openpref1.get_active():
                self.use_last_dir = True
            else:
                self.use_last_dir = False
            open_mode_prev = self.open_mode
            self.open_mode = combobox.get_active()
            preloading_images_prev = self.preloading_images
            self.preloading_images = preloadnav.get_active()
            self.listwrap_mode = combobox2.get_active()
            self.savemode = savecombo.get_active()
            self.thumbnail_size = int(self.thumbnail_sizes[thumbsize.get_active()])
            if self.thumbnail_size != prev_thumbnail_size:
                gobject.idle_add(self.thumbpane_set_size)
                gobject.idle_add(self.thumbpane_update_images, True, self.curr_img_in_list)
            self.prefs_dialog.destroy()
            self.set_go_navigation_sensitivities(False)
            if (self.preloading_images and not preloading_images_prev) or (open_mode_prev != self.open_mode):
                # The user just turned on preloading, so do it:
                self.preloadimg_next_in_list = -1
                self.preloadimg_prev_in_list = -1
                self.preload_when_idle = gobject.idle_add(self.preload_next_image, False)
                self.preload_when_idle2 = gobject.idle_add(self.preload_prev_image, False)
            elif not self.preloading_images:
                self.preloadimg_next_in_list = -1
                self.preloadimg_prev_in_list = -1

    def prefs_use_fixed_dir_clicked(self, button):
        if button.get_active():
            self.defaultdir.set_sensitive(True)
        else:
            self.defaultdir.set_sensitive(False)

    def select_rename_text(self, widget):
        filename = os.path.basename(self.currimg_name)
        fileext = os.path.splitext(os.path.basename(self.currimg_name))[1]
        self.rename_txt.select_region(0, len(filename) - len(fileext))

    def defaultdir_clicked(self, button):
        getdir = gtk.FileChooserDialog(title=("Choose directory"),action=gtk.FILE_CHOOSER_ACTION_OPEN,buttons=(gtk.STOCK_CANCEL,gtk.RESPONSE_CANCEL,gtk.STOCK_OPEN,gtk.RESPONSE_OK))
        getdir.set_action(gtk.FILE_CHOOSER_ACTION_SELECT_FOLDER)
        getdir.set_filename(self.fixed_dir)
        getdir.set_default_response(gtk.RESPONSE_OK)
        response = getdir.run()
        if response == gtk.RESPONSE_OK:
            self.fixed_dir = getdir.get_filenames()[0]
            if len(self.fixed_dir) > 25:
                button.set_label('...' + self.fixed_dir[-22:])
            else:
                button.set_label(self.fixed_dir)
            getdir.destroy()
        else:
            getdir.destroy()

    def prefs_tab_switched(self, notebook, page, page_num):
        do_when_idle = gobject.idle_add(self.grab_close_button)

    def grab_close_button(self):
        self.close_button.grab_focus()

    def bgcolor_selected(self, widget):
        # When the user selects a color, store this color in self.bgcolor (which will
        # later be saved to .miragerc) and set this background color:
        self.bgcolor = widget.get_property('color')
        self.layout.modify_bg(gtk.STATE_NORMAL, self.bgcolor)

    def mousewheel_scrolled(self, widget, event):
        if event.type == gtk.gdk.SCROLL:
            # Zooming of the image by Ctrl-mousewheel
            if event.state == gtk.gdk.CONTROL_MASK:
                if event.direction == gtk.gdk.SCROLL_UP:
                    self.zoom_out(None)
                elif event.direction == gtk.gdk.SCROLL_DOWN:
                    self.zoom_in(None)
                return True
            # Navigation of images with mousewheel:
            else:
                if event.direction == gtk.gdk.SCROLL_UP:
                    self.goto_prev_image(None)
                elif event.direction == gtk.gdk.SCROLL_DOWN:
                    self.goto_next_image(None)
                return True

    def mouse_moved(self, widget, event):
        # This handles the panning of the image
        if event.is_hint:
            x, y, state = event.window.get_pointer()
        else:
            state = event.state
        x, y = event.x_root, event.y_root
        if (state & gtk.gdk.BUTTON2_MASK) or (state & gtk.gdk.BUTTON1_MASK):
            # Prevent self.expose_event() from potentially further changing the
            # adjustments upon the adjustment value changes
            self.updating_adjustments = True
            xadjust = self.layout.get_hadjustment()
            newx = xadjust.value + (self.prevmousex - x)
            if newx >= xadjust.lower and newx <= xadjust.upper - xadjust.page_size:
                xadjust.set_value(newx)
                self.layout.set_hadjustment(xadjust)
            yadjust = self.layout.get_vadjustment()
            newy = yadjust.value + (self.prevmousey - y)
            if newy >= yadjust.lower and newy <= yadjust.upper - yadjust.page_size:
                yadjust.set_value(newy)
                self.layout.set_vadjustment(yadjust)
            self.updating_adjustments = False
        self.prevmousex = x
        self.prevmousey = y
        return True

    def button_pressed(self, widget, event):
        if self.image_loaded:
            # Changes the cursor to the 'resize' cursor, like GIMP, on a middle click:
            if (event.button == 2 or event.button == 1) and (self.hscroll.get_property('visible')==True or self.vscroll.get_property('visible')==True):
                self.change_cursor(gtk.gdk.Cursor(gtk.gdk.FLEUR))
                self.prevmousex = event.x_root
                self.prevmousey = event.y_root
            # Right-click popup:
            elif self.image_loaded and event.button == 3:
                self.UIManager.get_widget('/Popup').popup(None, None, None, event.button, event.time)
        return True

    def button_released(self, widget, event):
        # Resets the cursor when middle mouse button is released
        if event.button == 2 or event.button == 1:
            self.change_cursor(None)
        return True

    def zoom_in(self, action):
        if self.currimg_name != "" and self.UIManager.get_widget('/MainMenu/ViewMenu/In').get_property('sensitive'):
            self.image_zoomed = True
            self.currimg_zoomratio = self.currimg_zoomratio * 1.25
            self.set_zoom_sensitivities()
            self.last_image_action_was_fit = False
            self.put_zoom_image_to_window(False)
            self.update_statusbar()

    def zoom_out(self, action):
        if self.currimg_name != "" and self.UIManager.get_widget('/MainMenu/ViewMenu/Out').get_property('sensitive'):
            if self.currimg_zoomratio == self.min_zoomratio:
                # No point in proceeding..
                return
            self.image_zoomed = True
            self.currimg_zoomratio = self.currimg_zoomratio * 1/1.25
            if self.currimg_zoomratio < self.min_zoomratio:
                self.currimg_zoomratio = self.min_zoomratio
            self.set_zoom_sensitivities()
            self.last_image_action_was_fit = False
            self.put_zoom_image_to_window(False)
            self.update_statusbar()

    def zoom_to_fit_window_action(self, action):
        self.zoom_to_fit_window(action, False, False)

    def zoom_to_fit_window(self, action, is_preloadimg_next, is_preloadimg_prev):
        if is_preloadimg_next:
            if self.preloading_images and self.preloadimg_next_in_list != -1:
                win_width = self.available_image_width()
                win_height = self.available_image_height()
                preimg_width = self.preloadimg_next_pixbuf_original.get_width()
                preimg_height = self.preloadimg_next_pixbuf_original.get_height()
                prewidth_ratio = float(preimg_width)/win_width
                preheight_ratio = float(preimg_height)/win_height
                if prewidth_ratio < preheight_ratio:
                    premax_ratio = preheight_ratio
                else:
                    premax_ratio = prewidth_ratio
                self.preloadimg_next_zoomratio = 1/float(max_ratio)
        elif is_preloadimg_prev:
            if self.preloading_images and self.preloadimg_prev_in_list != -1:
                win_width = self.available_image_width()
                win_height = self.available_image_height()
                preimg_width = self.preloadimg_prev_pixbuf_original.get_width()
                preimg_height = self.preloadimg_prev_pixbuf_original.get_height()
                prewidth_ratio = float(preimg_width)/win_width
                preheight_ratio = float(preimg_height)/win_height
                if prewidth_ratio < preheight_ratio:
                    premax_ratio = preheight_ratio
                else:
                    premax_ratio = prewidth_ratio
                self.preloadimg_prev_zoomratio = 1/float(max_ratio)
        else:
            if self.currimg_name != "" and self.UIManager.get_widget('/MainMenu/ViewMenu/Fit').get_property('sensitive'):
                self.image_zoomed = True
                self.last_mode = self.open_mode_fit
                self.last_image_action_was_fit = True
                self.last_image_action_was_smart_fit = False
                # Calculate zoomratio needed to fit to window:
                win_width = self.available_image_width()
                win_height = self.available_image_height()
                img_width = self.currimg_pixbuf_original.get_width()
                img_height = self.currimg_pixbuf_original.get_height()
                width_ratio = float(img_width)/win_width
                height_ratio = float(img_height)/win_height
                if width_ratio < height_ratio:
                    max_ratio = height_ratio
                else:
                    max_ratio = width_ratio
                self.currimg_zoomratio = 1/float(max_ratio)
                self.set_zoom_sensitivities()
                self.put_zoom_image_to_window(False)
                self.update_statusbar()

    def zoom_to_fit_or_1_to_1(self, action, is_preloadimg_next, is_preloadimg_prev):
        if is_preloadimg_next:
            if self.preloading_images and self.preloadimg_next_in_list != -1:
                win_width = self.available_image_width()
                win_height = self.available_image_height()
                preimg_width = self.preloadimg_next_pixbuf_original.get_width()
                preimg_height = self.preloadimg_next_pixbuf_original.get_height()
                prewidth_ratio = float(preimg_width)/win_width
                preheight_ratio = float(preimg_height)/win_height
                if prewidth_ratio < preheight_ratio:
                    premax_ratio = preheight_ratio
                else:
                    premax_ratio = prewidth_ratio
                self.preloadimg_next_zoomratio = 1/float(premax_ratio)
                if self.preloadimg_next_zoomratio > 1:
                    self.preloadimg_next_zoomratio = 1
        elif is_preloadimg_prev:
            if self.preloading_images and self.preloadimg_prev_in_list != -1:
                win_width = self.available_image_width()
                win_height = self.available_image_height()
                preimg_width = self.preloadimg_prev_pixbuf_original.get_width()
                preimg_height = self.preloadimg_prev_pixbuf_original.get_height()
                prewidth_ratio = float(preimg_width)/win_width
                preheight_ratio = float(preimg_height)/win_height
                if prewidth_ratio < preheight_ratio:
                    premax_ratio = preheight_ratio
                else:
                    premax_ratio = prewidth_ratio
                self.preloadimg_prev_zoomratio = 1/float(premax_ratio)
                if self.preloadimg_prev_zoomratio > 1:
                    self.preloadimg_prev_zoomratio = 1
        else:
            if self.currimg_name != "":
                self.image_zoomed = True
                # Calculate zoomratio needed to fit to window:
                win_width = self.available_image_width()
                win_height = self.available_image_height()
                img_width = self.currimg_pixbuf_original.get_width()
                img_height = self.currimg_pixbuf_original.get_height()
                width_ratio = float(img_width)/win_width
                height_ratio = float(img_height)/win_height
                if width_ratio < height_ratio:
                    max_ratio = height_ratio
                else:
                    max_ratio = width_ratio
                self.currimg_zoomratio = 1/float(max_ratio)
                self.set_zoom_sensitivities()
                if self.currimg_zoomratio > 1:
                    # Revert to 1:1 zoom
                    self.zoom_1_to_1(action, False, False)
                else:
                    self.put_zoom_image_to_window(False)
                    self.update_statusbar()
                self.last_image_action_was_fit = True
                self.last_image_action_was_smart_fit = True

    def zoom_1_to_1_action(self, action):
        self.zoom_1_to_1(action, False, False)

    def zoom_1_to_1(self, action, is_preloadimg_next, is_preloadimg_prev):
        if is_preloadimg_next:
            if self.preloading_images:
                self.preloadimg_next_zoomratio = 1
        elif is_preloadimg_prev:
            if self.preloading_images:
                self.preloadimg_prev_zoomratio = 1
        else:
            if self.currimg_name != "" and (self.currimg_is_animation or (not self.currimg_is_animation and self.UIManager.get_widget('/MainMenu/ViewMenu/1:1').get_property('sensitive'))):
                self.image_zoomed = True
                self.last_mode = self.open_mode_1to1
                self.last_image_action_was_fit = False
                self.currimg_zoomratio = 1
                self.put_zoom_image_to_window(False)
                self.update_statusbar()

    def get_pixbuf_of_size(self, pixbuf, size):
        # Creates a pixbuf that fits in the specified square of sizexsize
        # while preserving the aspect ratio
        # Returns tuple: (scaled_pixbuf, actual_width, actual_height)
        image_width = pixbuf.get_width()
        image_height = pixbuf.get_height()
        if image_width-size > image_height-size:
            if image_width > size:
                image_height = int(size/float(image_width)*image_height)
                image_width = size
        else:
            if image_height > size:
                image_width = int(size/float(image_height)*image_width)
                image_height = size
        if not pixbuf.get_has_alpha():
            crop_pixbuf = pixbuf.scale_simple(image_width, image_height, self.zoom_quality)
        else:
            colormap = self.imageview.get_colormap()
            try:
                color1 = colormap.alloc_color(self.background[0], True, True)
                color2 = colormap.alloc_color(self.background[1], True, True)
            except ValueError:
                self.background = self.default_background
                color1 = colormap.alloc_color(self.background[0], True, True)
                color2 = colormap.alloc_color(self.background[1], True, True)
            crop_pixbuf = pixbuf.composite_color_simple(image_width, image_height, self.zoom_quality, 255, 8, color1.pixel, color2.pixel)
        return (crop_pixbuf, image_width, image_height)

    def pixbuf_add_border(self, pix):
        # Add a gray outline to pix. This will increase the pixbuf size by
        # 2 pixels lengthwise and heightwise, 1 on each side. Returns pixbuf.
        try:
            width = pix.get_width()
            height = pix.get_height()
            newpix = gtk.gdk.Pixbuf(gtk.gdk.COLORSPACE_RGB, True, 8, width+2, height+2)
            newpix.fill(0x858585ff)
            pix.copy_area(0, 0, width, height, newpix, 1, 1)
            return newpix
        except:
            return pix

    def aspect_ratio_toggled(self, togglebutton, width, height):
        self.preserve_aspect = togglebutton.get_active()
        if self.preserve_aspect:
            # Set height based on width and aspect ratio
            target_value = float(width.get_value_as_int())/self.currimg_pixbuf_original.get_width()
            target_value = int(target_value * self.currimg_pixbuf_original.get_height())
            self.ignore_preserve_aspect_callback = True
            height.set_value(target_value)
            self.ignore_preserve_aspect_callback = False

    def preserve_image_aspect(self, currspinbox, type, otherspinbox):
        if not self.preserve_aspect:
            return
        if self.ignore_preserve_aspect_callback:
            return
        if type == "width":
            target_value = float(currspinbox.get_value_as_int())/self.currimg_pixbuf_original.get_width()
            target_value = int(target_value * self.currimg_pixbuf_original.get_height())
        else:
            target_value = float(currspinbox.get_value_as_int())/self.currimg_pixbuf_original.get_height()
            target_value = int(target_value * self.currimg_pixbuf_original.get_width())
        self.ignore_preserve_aspect_callback = True
        otherspinbox.set_value(target_value)
        self.ignore_preserve_aspect_callback = False

    def goto_prev_image(self, action):
        self.goto_image("PREV", action)

    def goto_next_image(self, action):
        self.goto_image("NEXT", action)

    def goto_random_image(self, action):
        self.goto_image("RANDOM", action)

    def goto_first_image(self, action):
        self.goto_image("FIRST", action)

    def goto_last_image(self, action):
        self.goto_image("LAST", action)
        
    def goto_image(self, location, action):
        # location can be "LAST", "FIRST", "NEXT", "PREV", "RANDOM", or a number
        if ((location=="PREV" or location=="NEXT" or location=="RANDOM") and len(self.image_list) > 1) or (location=="FIRST" and (len(self.image_list) > 1 and self.curr_img_in_list != 0)) or (location=="LAST" and (len(self.image_list) > 1 and self.curr_img_in_list != len(self.image_list)-1)) or valid_int(location):
            self.load_new_image_stop_now()
            cancel = self.autosave_image()
            if cancel:
                return
            check_wrap = False
            if location != "RANDOM":
                self.randomlist = []
            if location == "FIRST":
                self.curr_img_in_list = 0
            elif location == "RANDOM":
                if self.randomlist == []:
                    self.reinitialize_randomlist()
                else:
                    # check if we have seen every image; if so, reinitialize array and repeat:
                    all_items_are_true = True
                    for item in self.randomlist:
                        if not item:
                            all_items_are_true = False
                    if all_items_are_true:
                        self.reinitialize_randomlist()
            elif location == "LAST":
                self.curr_img_in_list = len(self.image_list)-1
            elif location == "PREV":
                if self.curr_img_in_list > 0:
                    self.curr_img_in_list -= 1
                else:
                    check_wrap = True
            elif location == "NEXT":
                if self.curr_img_in_list < len(self.image_list) - 1:
                    self.curr_img_in_list += 1
                else:
                    check_wrap = True
            if check_wrap:
                if (location == "PREV" or location == "NEXT") and self.listwrap_mode == 1:
                    if location == "PREV":
                        self.curr_img_in_list = len(self.image_list) - 1
                    elif location == "NEXT":
                        self.curr_img_in_list = 0
                else:
                    if self.curr_img_in_list != self.loaded_img_in_list:
                        # Ensure that the user is looking at the correct "last" image before
                        # they are asked the wrap question:
                        if location == "PREV":
                            self.load_new_image(True, False, True, True, True, True)
                        else:
                            self.load_new_image(False, False, True, True, True, True)
                        self.set_go_navigation_sensitivities(False)
                        self.thumbpane_select(self.curr_img_in_list)
                    if location == "PREV":
                        dialog = gtk.MessageDialog(self.window, gtk.DIALOG_MODAL | gtk.DIALOG_DESTROY_WITH_PARENT, gtk.MESSAGE_QUESTION, gtk.BUTTONS_YES_NO, ("You are viewing the first image in the list. Wrap around to the last image?"))
                    elif location == "NEXT":
                        dialog = gtk.MessageDialog(self.window, gtk.DIALOG_MODAL | gtk.DIALOG_DESTROY_WITH_PARENT, gtk.MESSAGE_QUESTION, gtk.BUTTONS_YES_NO, ("You are viewing the last image in the list. Wrap around to the first image?"))
                    elif location == "RANDOM":
                        dialog = gtk.MessageDialog(self.window, gtk.DIALOG_MODAL | gtk.DIALOG_DESTROY_WITH_PARENT, gtk.MESSAGE_QUESTION, gtk.BUTTONS_YES_NO, ("All images have been viewed. Would you like to cycle through the images again?"))
                    dialog.set_title(("Wrap?"))
                    dialog.set_default_response(gtk.RESPONSE_YES)
                    self.user_prompt_visible = True
                    response = dialog.run()
                    if response == gtk.RESPONSE_YES:
                        if location == "PREV":
                            self.curr_img_in_list = len(self.image_list)-1
                        elif location == "NEXT":
                            self.curr_img_in_list = 0
                        elif location == "RANDOM":
                            self.reinitialize_randomlist()
                        dialog.destroy()
                        self.user_prompt_visible = False
                    else:
                        dialog.destroy()
                        self.user_prompt_visible = False
                        self.change_cursor(None)
                        return
            if location == "RANDOM":
                # Find random image that hasn't already been chosen:
                j = random.randint(0, len(self.image_list)-1)
                while self.randomlist[j]:
                    j = random.randint(0, len(self.image_list)-1)
                self.curr_img_in_list = j
                self.randomlist[j] = True
                self.currimg_name = str(self.image_list[self.curr_img_in_list])
            if valid_int(location):
                prev_img = self.curr_img_in_list
                self.curr_img_in_list = int(location)
                self.currimg_name = str(self.image_list[self.curr_img_in_list])
            self.change_cursor(gtk.gdk.Cursor(gtk.gdk.WATCH))
            if location == "PREV":
                self.load_when_idle = gobject.idle_add(self.load_new_image, True, False, True, True, True, True)
            else:
                self.load_when_idle = gobject.idle_add(self.load_new_image, False, False, True, True, True, True)
            self.set_go_navigation_sensitivities(False)
            gobject.idle_add(self.thumbpane_select, self.curr_img_in_list)
        
    def set_go_navigation_sensitivities(self, skip_initial_check):
        # setting skip_image_list_check to True is useful when calling from
        # expand_filelist_and_load_image() for example, as self.image_list has not
        # yet fully populated
        if (not self.image_loaded or len(self.image_list) == 1) and not skip_initial_check:
            self.set_previous_image_sensitivities(False)
            self.set_first_image_sensitivities(False)
            self.set_next_image_sensitivities(False)
            self.set_last_image_sensitivities(False)
            self.set_random_image_sensitivities(False)
        elif self.curr_img_in_list == 0:
            if self.listwrap_mode == 0:
                self.set_previous_image_sensitivities(False)
            else:
                self.set_previous_image_sensitivities(True)
            self.set_first_image_sensitivities(False)
            self.set_next_image_sensitivities(True)
            self.set_last_image_sensitivities(True)
            self.set_random_image_sensitivities(True)
        elif self.curr_img_in_list == len(self.image_list)-1:
            self.set_previous_image_sensitivities(True)
            self.set_first_image_sensitivities(True)
            if self.listwrap_mode == 0:
                self.set_next_image_sensitivities(False)
            else:
                self.set_next_image_sensitivities(True)
            self.set_last_image_sensitivities(False)
            self.set_random_image_sensitivities(True)
        else:
            self.set_previous_image_sensitivities(True)
            self.set_first_image_sensitivities(True)
            self.set_next_image_sensitivities(True)
            self.set_last_image_sensitivities(True)
            self.set_random_image_sensitivities(True)

    def reinitialize_randomlist(self):
        self.randomlist = []
        for i in range(len(self.image_list)):
            self.randomlist.append(False)
        self.randomlist[self.curr_img_in_list] = True

    def image_load_failed(self, reset_cursor, filename=""):
        # If a filename is provided, use it for display:
        if len(filename) == 0:
            self.currimg_name = str(self.image_list[self.curr_img_in_list])
        else:
            self.currmg_name = filename
        if self.verbose and self.currimg_name != "":
            print ("Loading") + ":", self.currimg_name
        self.update_title()
        self.put_error_image_to_window()
        self.image_loaded = False
        self.currimg_pixbuf_original = None
        if reset_cursor:
            self.change_cursor(None)

    def load_new_image_stop_now(self):
        try:
            gobject.source_remove(self.load_when_idle)
        except:
            pass
        try:
            gobject.source_remove(self.preload_when_idle)
        except:
            pass
        try:
            gobject.source_remove(self.preload_when_idle2)
        except:
            pass

    def load_new_image(self, check_prev_last, use_current_pixbuf_original, reset_cursor, perform_onload_action, preload_next_image_after, preload_prev_image_after):
        try:
            self.load_new_image2(check_prev_last, use_current_pixbuf_original, reset_cursor, perform_onload_action)
        except:
            self.image_load_failed(True)
        if preload_next_image_after:
            self.preload_when_idle = gobject.idle_add(self.preload_next_image, False)
        if preload_prev_image_after:
            self.preload_when_idle2 = gobject.idle_add(self.preload_prev_image, False)

    def check_preloadimg_prev_for_existing(self, prev_index, reset_preloadimg_prev_in_list):
        # Determines if preloadimg_prev needs to be updated; if so,
        # checks if the image is already stored in self.currimg
        # or self.preloadimg_next and can be reused.
        reset_preloadimg_prev_in_list = False
        if prev_index != self.preloadimg_prev_in_list and prev_index != -1:
            # Need to update preloadimg_prev:
            if prev_index == self.loaded_img_in_list and not self.image_modified and not self.image_zoomed:
                self.preloadimg_prev_in_list = self.loaded_img_in_list
                self.preloadimg_prev_name = self.currimg_name
                self.preloadimg_prev_width = self.currimg_width
                self.preloadimg_prev_height = self.currimg_height
                self.preloadimg_prev_pixbuf = self.currimg_pixbuf
                self.preloadimg_prev_pixbuf_original = self.currimg_pixbuf_original
                self.preloadimg_prev_zoomratio = self.currimg_zoomratio
                self.preloadimg_prev_is_animation = self.currimg_is_animation
            elif prev_index == self.preloadimg_next_in_list:
                self.preloadimg_prev_in_list = self.preloadimg_next_in_list
                self.preloadimg_prev_name = self.preloadimg_next_name
                self.preloadimg_prev_width = self.preloadimg_next_width
                self.preloadimg_prev_height = self.preloadimg_next_height
                self.preloadimg_prev_pixbuf = self.preloadimg_next_pixbuf
                self.preloadimg_prev_pixbuf_original = self.preloadimg_next_pixbuf_original
                self.preloadimg_prev_zoomratio = self.preloadimg_next_zoomratio
                self.preloadimg_prev_is_animation = self.preloadimg_next_is_animation
            else:
                reset_preloadimg_prev_in_list = True
        elif prev_index == -1:
            reset_preloadimg_prev_in_list = True

    def check_preloadimg_next_for_existing(self, next_index, reset_preloadimg_next_in_list):
        # Determines if preloadimg_next needs to be updated; if so,
        # checks if the image is already stored in self.currimg
        # or self.preloadimg_prev and can be reused.
        reset_preloadimg_next_in_list = False
        if next_index != self.preloadimg_next_in_list and next_index != -1:
            # Need to update preloadimg_next:
            if next_index == self.loaded_img_in_list and not self.image_modified and not self.image_zoomed:
                self.preloadimg_next_in_list = self.loaded_img_in_list
                self.preloadimg_next_name = self.currimg_name
                self.preloadimg_next_width = self.currimg_width
                self.preloadimg_next_height = self.currimg_height
                self.preloadimg_next_pixbuf = self.currimg_pixbuf
                self.preloadimg_next_pixbuf_original = self.currimg_pixbuf_original
                self.preloadimg_next_zoomratio = self.currimg_zoomratio
                self.preloadimg_next_is_animation = self.currimg_is_animation
            elif next_index == self.preloadimg_prev_in_list:
                self.preloadimg_next_in_list = self.preloadimg_prev_in_list
                self.preloadimg_next_name = self.preloadimg_prev_name
                self.preloadimg_next_width = self.preloadimg_prev_width
                self.preloadimg_next_height = self.preloadimg_prev_height
                self.preloadimg_next_pixbuf = self.preloadimg_prev_pixbuf
                self.preloadimg_next_pixbuf_original = self.preloadimg_prev_pixbuf_original
                self.preloadimg_next_zoomratio = self.preloadimg_prev_zoomratio
                self.preloadimg_next_is_animation = self.preloadimg_prev_is_animation
            else:
                reset_preloadimg_next_in_list = True
        elif next_index == -1:
            reset_preloadimg_next_in_list = True

    def check_currimg_for_existing(self):
        # Determines if currimg needs to be updated; if so,
        # checks if the image is already stored in self.preloadimg_next
        # or self.preloadimg_prev and can be reused (the whole point of
        # preloading!)
        used_prev = False
        used_next = False
        if self.curr_img_in_list != self.loaded_img_in_list:
            # Need to update currimg:
            if self.curr_img_in_list == self.preloadimg_prev_in_list:
                # Set preload_prev_image as current image
                self.currimg_name = self.preloadimg_prev_name
                self.currimg_width = self.preloadimg_prev_width
                self.currimg_height = self.preloadimg_prev_height
                self.currimg_pixbuf = self.preloadimg_prev_pixbuf
                self.currimg_pixbuf_original = self.preloadimg_prev_pixbuf_original
                self.currimg_zoomratio = self.preloadimg_prev_zoomratio
                self.currimg_is_animation = self.preloadimg_prev_is_animation
                used_prev = True
                if self.verbose and self.currimg_name != "":
                    print ("Loading") + ":", self.currimg_name
                self.put_zoom_image_to_window(True)
                if not self.currimg_is_animation:
                    self.set_image_sensitivities(True)
                else:
                    self.set_image_sensitivities(False)
            elif self.curr_img_in_list == self.preloadimg_next_in_list:
                # Use preload_next_image as current image
                self.currimg_name = self.preloadimg_next_name
                self.currimg_width = self.preloadimg_next_width
                self.currimg_height = self.preloadimg_next_height
                self.currimg_pixbuf = self.preloadimg_next_pixbuf
                self.currimg_pixbuf_original = self.preloadimg_next_pixbuf_original
                self.currimg_zoomratio = self.preloadimg_next_zoomratio
                self.currimg_is_animation = self.preloadimg_next_is_animation
                used_next = True
                if self.verbose and self.currimg_name != "":
                    print ("Loading") + ":", self.currimg_name
                self.put_zoom_image_to_window(True)
                if not self.currimg_is_animation:
                    self.set_image_sensitivities(True)
                else:
                    self.set_image_sensitivities(False)
        return used_prev, used_next

    def load_new_image2(self, check_prev_last, use_current_pixbuf_original, reset_cursor, perform_onload_action):
        # check_prev_last is used to determine if we should check whether
        # preloadimg_prev can be reused last. This should really only
        # be done if the user just clicked the previous image button in
        # order to reduce the number of image loads.
        # If use_current_pixbuf_original == True, do not reload the
        # self.currimg_pixbuf_original from the file; instead, use the existing
        # one. This is only currently useful for resizing images.
        # Determine the indices in the self.image_list array for the
        # previous and next preload images.
        next_index = self.curr_img_in_list + 1
        if next_index > len(self.image_list)-1:
            if self.listwrap_mode == 0:
                next_index = -1
            else:
                next_index = 0
        prev_index = self.curr_img_in_list - 1
        if prev_index < 0:
            if self.listwrap_mode == 0:
                prev_index = -1
            else:
                prev_index = len(self.image_list)-1
        if self.preloading_images:
            reset_preloadimg_next_in_list = False
            reset_preloadimg_prev_in_list = False
            if check_prev_last:
                self.check_preloadimg_next_for_existing(next_index, reset_preloadimg_next_in_list)
            else:
                self.check_preloadimg_prev_for_existing(prev_index, reset_preloadimg_prev_in_list)
        used_prev, used_next = self.check_currimg_for_existing()
        if self.preloading_images:
            if check_prev_last:
                self.check_preloadimg_prev_for_existing(prev_index, reset_preloadimg_prev_in_list)
            else:
                self.check_preloadimg_next_for_existing(next_index, reset_preloadimg_next_in_list)
            if reset_preloadimg_prev_in_list:
                self.preloadimg_prev_in_list = -1
            if reset_preloadimg_next_in_list:
                self.preloadimg_next_in_list = -1
        if used_prev or used_next:
            # If we used a preload image, set the correct boolean variables
            if self.open_mode == self.open_mode_smart or (self.open_mode == self.open_mode_last and self.last_mode == self.open_mode_smart):
                self.last_image_action_was_fit = True
                self.last_image_action_was_smart_fit = True
            elif self.open_mode == self.open_mode_fit or (self.open_mode == self.open_mode_last and self.last_mode == self.open_mode_fit):
                self.last_image_action_was_fit = True
                self.last_image_action_was_smart_fit = False
            elif self.open_mode == self.open_mode_1to1 or (self.open_mode == self.open_mode_last and self.last_mode == self.open_mode_1to1):
                self.last_image_action_was_fit = False
        else:
            # Need to load the current image
            self.currimg_pixbuf = None
            self.currimg_zoomratio = 1
            self.currimg_name = str(self.image_list[self.curr_img_in_list])
            if self.verbose and self.currimg_name != "":
                print ("Loading") + ":", self.currimg_name
            animtest = gtk.gdk.PixbufAnimation(self.currimg_name)
            if animtest.is_static_image() or (use_current_pixbuf_original and not self.currimg_is_animation):
                self.currimg_is_animation = False
                if not use_current_pixbuf_original:
                    self.currimg_pixbuf_original = animtest.get_static_image()
                self.set_image_sensitivities(True)
                if self.open_mode == self.open_mode_smart or (self.open_mode == self.open_mode_last and self.last_mode == self.open_mode_smart):
                    self.zoom_to_fit_or_1_to_1(None, False, False)
                elif self.open_mode == self.open_mode_fit or (self.open_mode == self.open_mode_last and self.last_mode == self.open_mode_fit):
                    self.zoom_to_fit_window(None, False, False)
                elif self.open_mode == self.open_mode_1to1 or (self.open_mode == self.open_mode_last and self.last_mode == self.open_mode_1to1):
                    self.zoom_1_to_1(None, False, False)
            else:
                self.currimg_is_animation = True
                if not use_current_pixbuf_original:
                    self.currimg_pixbuf_original = animtest
                self.zoom_1_to_1(None, False, False)
                self.set_image_sensitivities(False)
        self.update_statusbar()
        self.update_title()
        self.image_loaded = True
        self.image_modified = False
        self.image_zoomed = False
        if reset_cursor:
            self.change_cursor(None)

    def preload_next_image(self, use_existing_image):
        try:
            if self.preloading_images and len(self.image_list) > 1:
                if not use_existing_image:
                    next_index = self.curr_img_in_list + 1
                    if next_index > len(self.image_list)-1:
                        if self.listwrap_mode == 0:
                            self.preloadimg_next_in_list == -1
                            return
                        else:
                            next_index = 0
                    if next_index == self.preloadimg_next_in_list:
                        return
                    self.preloadimg_next_in_list = next_index
                    self.preloadimg_next_name = str(self.image_list[next_index])
                    pre_animtest = gtk.gdk.PixbufAnimation(self.preloadimg_next_name)
                    if pre_animtest.is_static_image():
                        self.preloadimg_next_is_animation = False
                        self.preloadimg_next_pixbuf_original = pre_animtest.get_static_image()
                    else:
                        self.preloadimg_next_is_animation = True
                        self.preloadimg_next_pixbuf_original = pre_animtest
                if self.preloadimg_next_in_list == -1:
                    return
                # Determine self.preloadimg_next_zoomratio
                if self.open_mode == self.open_mode_smart or (self.open_mode == self.open_mode_last and self.last_mode == self.open_mode_smart):
                    self.zoom_to_fit_or_1_to_1(None, True, False)
                elif self.open_mode == self.open_mode_fit or (self.open_mode == self.open_mode_last and self.last_mode == self.open_mode_fit):
                    self.zoom_to_fit_window(None, True, False)
                elif self.open_mode == self.open_mode_1to1 or (self.open_mode == self.open_mode_last and self.last_mode == self.open_mode_1to1):
                    self.zoom_1_to_1(None, True, False)
                # Always start with the original image to preserve quality!
                # Calculate image size:
                self.preloadimg_next_width = int(self.preloadimg_next_pixbuf_original.get_width() * self.preloadimg_next_zoomratio)
                self.preloadimg_next_height = int(self.preloadimg_next_pixbuf_original.get_height() * self.preloadimg_next_zoomratio)
                if not self.preloadimg_next_is_animation:
                    # Scale image:
                    if not self.preloadimg_next_pixbuf_original.get_has_alpha():
                        self.preloadimg_next_pixbuf = self.preloadimg_next_pixbuf_original.scale_simple(self.preloadimg_next_width, self.preloadimg_next_height, self.zoom_quality)
                    else:
                        colormap = self.imageview.get_colormap()
                        try:
                            color1 = colormap.alloc_color(self.background[0], True, True)
                            color2 = colormap.alloc_color(self.background[1], True, True)
                        except ValueError:
                            self.background = self.default_background
                            color1 = colormap.alloc_color(self.background[0], True, True)
                            color2 = colormap.alloc_color(self.background[1], True, True)
                        self.preloadimg_next_pixbuf = self.preloadimg_next_pixbuf_original.composite_color_simple(self.preloadimg_next_width, self.preloadimg_next_height, self.zoom_quality, 255, 8, color1.pixel, color2.pixel)
                else:
                    self.preloadimg_next_pixbuf = self.preloadimg_next_pixbuf_original
                gc.collect()
                if self.verbose:
                    print ("Preloading") + ":", self.preloadimg_next_name
        except:
            self.preloadimg_next_in_list = -1

    def preload_prev_image(self, use_existing_image):
        try:
            if self.preloading_images and len(self.image_list) > 1:
                if not use_existing_image:
                    prev_index = self.curr_img_in_list - 1
                    if prev_index < 0:
                        if self.listwrap_mode == 0:
                            self.preloadimg_prev_in_list == -1
                            return
                        else:
                            prev_index = len(self.image_list)-1
                    if prev_index == self.preloadimg_prev_in_list:
                        return
                    self.preloadimg_prev_in_list = prev_index
                    self.preloadimg_prev_name = str(self.image_list[prev_index])
                    pre_animtest = gtk.gdk.PixbufAnimation(self.preloadimg_prev_name)
                    if pre_animtest.is_static_image():
                        self.preloadimg_prev_is_animation = False
                        self.preloadimg_prev_pixbuf_original = pre_animtest.get_static_image()
                    else:
                        self.preloadimg_prev_is_animation = True
                        self.preloadimg_prev_pixbuf_original = pre_animtest
                if self.preloadimg_prev_in_list == -1:
                    return
                # Determine self.preloadimg_prev_zoomratio
                if self.open_mode == self.open_mode_smart or (self.open_mode == self.open_mode_last and self.last_mode == self.open_mode_smart):
                    self.zoom_to_fit_or_1_to_1(None, False, True)
                elif self.open_mode == self.open_mode_fit or (self.open_mode == self.open_mode_last and self.last_mode == self.open_mode_fit):
                    self.zoom_to_fit_window(None, False, True)
                elif self.open_mode == self.open_mode_1to1 or (self.open_mode == self.open_mode_last and self.last_mode == self.open_mode_1to1):
                    self.zoom_1_to_1(None, False, True)
                # Always start with the original image to preserve quality!
                # Calculate image size:
                self.preloadimg_prev_width = int(self.preloadimg_prev_pixbuf_original.get_width() * self.preloadimg_prev_zoomratio)
                self.preloadimg_prev_height = int(self.preloadimg_prev_pixbuf_original.get_height() * self.preloadimg_prev_zoomratio)
                if not self.preloadimg_prev_is_animation:
                    # Scale image:
                    if not self.preloadimg_prev_pixbuf_original.get_has_alpha():
                        self.preloadimg_prev_pixbuf = self.preloadimg_prev_pixbuf_original.scale_simple(self.preloadimg_prev_width, self.preloadimg_prev_height, self.zoom_quality)
                    else:
                        colormap = self.imageview.get_colormap()
                        try:
                            color1 = colormap.alloc_color(self.background[0], True, True)
                            color2 = colormap.alloc_color(self.background[1], True, True)
                        except ValueError:
                            self.background = self.default_background
                            color1 = colormap.alloc_color(self.background[0], True, True)
                            color2 = colormap.alloc_color(self.background[1], True, True)
                        self.preloadimg_prev_pixbuf = self.preloadimg_prev_pixbuf_original.composite_color_simple(self.preloadimg_prev_width, self.preloadimg_prev_height, self.zoom_quality, 255, 8, color1.pixel, color2.pixel)
                else:
                    self.preloadimg_prev_pixbuf = self.preloadimg_prev_pixbuf_original
                gc.collect()
                if self.verbose:
                    print ("Preloading") + ":", self.preloadimg_prev_name
        except:
            self.preloadimg_prev_in_list = -1

    def change_cursor(self, type):
        for i in gtk.gdk.window_get_toplevels():
            if i.get_window_type() != gtk.gdk.WINDOW_TEMP and i.get_window_type() != gtk.gdk.WINDOW_CHILD:
                i.set_cursor(type)
        self.layout.window.set_cursor(type)

    def expand_filelist_and_load_image(self, inputlist):
        # Takes the current list (i.e. ["pic.jpg", "pic2.gif", "../images"]) and
        # expands it into a list of all pictures found
        self.thumblist.clear()
        first_image_loaded_successfully = False
        self.images_found = 0
        self.stop_now = True # Make sure that any previous search process is stopped
        self.change_cursor(gtk.gdk.Cursor(gtk.gdk.WATCH))
        # Reset preload images:
        self.preloadimg_next_in_list = -1
        self.preloadimg_prev_in_list = -1
        # If any directories were passed, display "Searching..." in statusbar:
        self.searching_for_images = False
        for item in inputlist:
            if os.path.isdir(item):
                self.searching_for_images = True
                self.update_statusbar()
        if not self.closing_app:
            while gtk.events_pending():
                gtk.main_iteration()
        first_image = ""
        first_image_found = False
        first_image_loaded = False
        second_image = ""
        second_image_found = False
        second_image_preloaded = False
        self.randomlist = []
        folderlist = []
        self.image_list = []
        self.curr_img_in_list = 0
        go_buttons_enabled = False
        self.set_go_sensitivities(False)
        # Clean up list (remove preceding "file://" or "file:" and trailing "/")
        for itemnum in range(len(inputlist)):
            # Strip off preceding file..
            if inputlist[itemnum].startswith('file://'):
                inputlist[itemnum] = inputlist[itemnum][7:]
            elif inputlist[itemnum].startswith('file:'):
                inputlist[itemnum] = inputlist[itemnum][5:]
            # Strip off trailing "/" if it exists:
            if inputlist[itemnum][len(inputlist[itemnum])-1] == "/":
                inputlist[itemnum] = inputlist[itemnum][:(len(inputlist[itemnum])-1)]
            if not (inputlist[itemnum].startswith('http://') or inputlist[itemnum].startswith('ftp://')):
                inputlist[itemnum] = os.path.abspath(inputlist[itemnum])
            else:
                try:
                    # Remote file. Save as /tmp/mirage-<random>/filename.ext
                    tmpdir = tempfile.mkdtemp(prefix="mirage-") + "/"
                    tmpfile = tmpdir + os.path.basename(inputlist[itemnum])
                    socket.setdefaulttimeout(5)
                    urllib.urlretrieve(inputlist[itemnum], tmpfile)
                    inputlist[itemnum] = tmpfile
                except:
                    pass
        # Remove hidden files from list:
        if not self.open_hidden_files:
            tmplist = []
            for item in inputlist:
                if os.path.basename(item)[0] != '.':
                    tmplist.append(item)
                elif self.verbose:
                    print ("Skipping") + ":", item
            inputlist = tmplist
            if len(inputlist) == 0:
                # All files/dirs were hidden, exit..
                self.currimg_name = ""
                self.searching_for_images = False
                self.set_go_navigation_sensitivities(False)
                if not self.closing_app:
                    self.change_cursor(None)
                self.recursive = False
                self.put_error_image_to_window()
                self.update_title()
                return
        init_image = os.path.abspath(inputlist[0])
        self.stop_now = False
        # If open all images in dir...
        if self.open_all_images:
            temp = inputlist
            inputlist = []
            for item in temp:
                if os.path.isfile(item):
                    itempath = os.path.dirname(os.path.abspath(item))
                    temp = self.recursive
                    self.recursive = False
                    self.stop_now = False
                    self.expand_directory(itempath, False, go_buttons_enabled, False, False)
                    self.recursive = temp
                else:
                    inputlist.append(item)
            for item in self.image_list:
                inputlist.append(item)
                if first_image_found and not second_image_found:
                    second_image_found = True
                    second_image = item
                    second_image_came_from_dir = False
                if item == init_image:
                    first_image_found = True
                    first_image = item
                    first_image_came_from_dir = False
                    self.curr_img_in_list = len(inputlist)-1
        self.image_list = []
        for item in inputlist:
            if not self.closing_app:
                if os.path.isfile(item):
                    if self.valid_image(item):
                        if not second_image_found and first_image_found:
                            second_image_found = True
                            second_image = item
                            second_image_came_from_dir = False
                        if not first_image_found:
                            first_image_found = True
                            first_image = item
                            first_image_came_from_dir = False
                        self.image_list.append(item)
                        if self.verbose:
                            self.images_found += 1
                            print ("Found") + ":", item, "[" + str(self.images_found) + "]"
                else:
                    # If it's a directory that was explicitly selected or passed to
                    # the program, get all the files in the dir.
                    # Retrieve only images in the top directory specified by the user
                    # unless explicitly told to recurse (via -R or in Settings>Preferences)
                    folderlist.append(item)
                    if not second_image_found:
                        # See if we can find an image in this directory:
                        self.stop_now = False
                        self.expand_directory(item, True, go_buttons_enabled, False, False)
                        itemnum = 0
                        while itemnum < len(self.image_list) and not second_image_found:
                            if os.path.isfile(self.image_list[itemnum]):
                                if not second_image_found and first_image_found:
                                    second_image_found = True
                                    second_image_came_from_dir = True
                                    second_image = self.image_list[itemnum]
                                    self.set_go_navigation_sensitivities(True)
                                    go_buttons_enabled = True
                                    while gtk.events_pending():
                                        gtk.main_iteration(True)
                                if not first_image_found:
                                    first_image_found = True
                                    first_image = self.image_list[itemnum]
                                    first_image_came_from_dir = True
                            itemnum += 1
                # Load first image and display:
                if first_image_found and not first_image_loaded and self.curr_img_in_list <= len(self.image_list)-1:
                    first_image_loaded = True
                    if self.verbose and self.currimg_name != "":
                        print ("Loading") + ":", self.currimg_name
                    try:
                        self.load_new_image2(False, False, True, True)
                        # Calling load_new_image2 will reset the following two vars
                        # to 0, so ensure they are -1 again (no images preloaded)
                        self.preloadimg_prev_in_list = -1
                        self.preloadimg_next_in_list = -1
                        if not self.currimg_is_animation:
                            self.previmg_width = self.currimg_pixbuf.get_width()
                        else:
                            self.previmg_width = self.currimg_pixbuf.get_static_image().get_width()
                        self.image_loaded = True
                        first_image_loaded_successfully = True
                        if not self.closing_app:
                            while gtk.events_pending():
                                gtk.main_iteration(True)
                    except:
                        pass
                    if first_image_came_from_dir:
                        self.image_list = []
                # Pre-load second image:
                if second_image_found and not second_image_preloaded and ((not second_image_came_from_dir and self.curr_img_in_list+1 <= len(self.image_list)-1) or second_image_came_from_dir):
                    second_image_preloaded = True
                    temp = self.image_list
                    self.image_list = []
                    while len(self.image_list) < self.curr_img_in_list+1:
                        self.image_list.append(first_image)
                    self.image_list.append(second_image)
                    self.preload_next_image(False)
                    self.image_list = temp
        if first_image_found:
            # Sort the filelist and folderlist alphabetically, and recurse into folderlist:
            if first_image_came_from_dir:
                self.add_folderlist_images(folderlist, go_buttons_enabled)
                self.do_image_list_stuff(first_image, second_image)
            else:
                self.do_image_list_stuff(first_image, second_image)
                self.add_folderlist_images(folderlist, go_buttons_enabled)
            self.update_title()
            if not self.closing_app:
                while gtk.events_pending():
                    gtk.main_iteration(True)
        if not first_image_loaded_successfully:
            self.image_load_failed(False, inputlist[0])
        self.searching_for_images = False
        self.update_statusbar()
        self.set_go_navigation_sensitivities(False)
        self.thumbpane_update_images(True, self.curr_img_in_list)
        if not self.closing_app:
            self.change_cursor(None)
        self.recursive = False

    def add_folderlist_images(self, folderlist, go_buttons_enabled):
        if len(folderlist) > 0:
            folderlist.sort(locale.strcoll)
            folderlist = list(set(folderlist))
            for item in folderlist:
                if not self.closing_app:
                    if (not self.open_hidden_files and os.path.basename(item)[0] != '.') or self.open_hidden_files:
                        self.stop_now = False
                        self.expand_directory(item, False, go_buttons_enabled, True, True)

    def do_image_list_stuff(self, first_image, second_image):
        if len(self.image_list) > 0:
            self.set_go_navigation_sensitivities(True)
            self.image_list = list(set(self.image_list))
            self.image_list.sort(locale.strcoll)

    def expand_directory(self, item, stop_when_second_image_found, go_buttons_enabled, update_window_title, print_found_msg):
        if not self.stop_now and not self.closing_app:
            folderlist = []
            filelist = []
            if not os.access(item, os.R_OK):
                return False
            for item2 in os.listdir(item):
                if not self.closing_app and not self.stop_now:
                    while gtk.events_pending():
                        gtk.main_iteration(True)
                    item2 = item + "/" + item2
                    item_fullpath2 = os.path.abspath(item2)
                    if (not self.open_hidden_files and os.path.basename(item_fullpath2)[0] != '.') or self.open_hidden_files:
                        if os.path.isfile(item_fullpath2) and self.valid_image(item_fullpath2):
                            filelist.append(item2)
                            if self.verbose and print_found_msg:
                                self.images_found += 1
                                print ("Found") + ":", item_fullpath2, "[" + str(self.images_found) + "]"
                        elif os.path.isdir(item_fullpath2) and self.recursive:
                            folderlist.append(item_fullpath2)
                    elif self.verbose:
                        print ("Skipping") + ":", item_fullpath2
            if len(self.image_list)>0 and update_window_title:
                self.update_title()
            # Sort the filelist and folderlist alphabetically:
            if len(filelist) > 0:
                filelist.sort(locale.strcoll)
                for item2 in filelist:
                    if not item2 in self.image_list:
                        self.image_list.append(item2)
                        if stop_when_second_image_found and len(self.image_list)==2:
                            return
                        if not go_buttons_enabled and len(self.image_list) > 1:
                            self.set_go_navigation_sensitivities(True)
                            go_buttons_enabled = True
            # Recurse into the folderlist:
            if len(folderlist) > 0:
                folderlist.sort(locale.strcoll)
                for item2 in folderlist:
                    if not self.stop_now:
                        self.expand_directory(item2, stop_when_second_image_found, go_buttons_enabled, update_window_title, print_found_msg)

    def valid_image(self, file):
        test = gtk.gdk.pixbuf_get_file_info(file)
        if test == None:
            return False
        elif test[0]['name'] == "wbmp":
            # some regular files are thought to be wbmp for whatever reason,
            # so let's check further.. :(
            try:
                test2 = gtk.gdk.pixbuf_new_from_file(file)
                return True
            except:
                return False
        else:
            return True

    def update_title(self):
        if len(self.image_list) == 0:
            title = ""
        elif len(self.image_list) == 1:
            title = os.path.basename(self.currimg_name)
        else:
            title = "[" + str(self.curr_img_in_list+1) + ' ' + ('of') + ' ' + str(len(self.image_list)) + "] " + os.path.basename(self.currimg_name)
        self.window.set_title(title)

    def main(self):
        gtk.main()

if __name__ == "__main__":
    base = Base()
    # gtk.gdk.threads_enter()
    base.main()
    # gtk.gdk.threads_leave()
